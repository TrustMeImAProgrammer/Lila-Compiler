Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    COMMENT
    CHARLITERAL
    TIMESEQUALS
    DIVEQUALS
    PLUSEQUALS
    MINUSEQUALS

Grammar

Rule 0     S' -> program
Rule 1     program -> translation_unit
Rule 2     translation_unit -> statement
Rule 3     translation_unit -> translation_unit statement
Rule 4     statement -> assignment
Rule 5     statement -> func_call
Rule 6     statement -> return_statement
Rule 7     statement -> func_declaration
Rule 8     statement -> if_statement
Rule 9     statement -> while_statement
Rule 10    assignment -> ID EQUALS expression
Rule 11    assignment -> type_info ID EQUALS expression
Rule 12    assignment -> ID PLUSPLUS
Rule 13    assignment -> ID MINUSMINUS
Rule 14    func_call -> CALL identifier LPAREN arguments_list RPAREN
Rule 15    func_call -> CALL identifier LPAREN RPAREN
Rule 16    return_statement -> RETURN expression
Rule 17    func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
Rule 18    func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
Rule 19    if_statement -> IF binary_op LBRACKET translation_unit RBRACKET
Rule 20    while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET
Rule 21    params_list -> parameter_declaration
Rule 22    params_list -> params_list COMMA parameter_declaration
Rule 23    parameter_declaration -> type_info ID
Rule 24    arguments_list -> expression
Rule 25    arguments_list -> arguments_list COMMA expression
Rule 26    expression -> simple_expression
Rule 27    expression -> func_call
Rule 28    expression -> atom
Rule 29    simple_expression -> binary_op
Rule 30    simple_expression -> unary_op
Rule 31    atom -> identifier
Rule 32    atom -> constant
Rule 33    identifier -> ID
Rule 34    constant -> NUMBER
Rule 35    constant -> SLITERAL
Rule 36    constant -> FLOAT
Rule 37    constant -> TRUE
Rule 38    constant -> FALSE
Rule 39    binary_op -> expression AND expression
Rule 40    binary_op -> expression OR expression
Rule 41    binary_op -> expression GT expression
Rule 42    binary_op -> expression LT expression
Rule 43    binary_op -> expression GE expression
Rule 44    binary_op -> expression LE expression
Rule 45    binary_op -> expression ISEQUALS expression
Rule 46    binary_op -> expression MODULO expression
Rule 47    binary_op -> expression PLUS expression
Rule 48    binary_op -> expression MINUS expression
Rule 49    binary_op -> expression TIMES expression
Rule 50    binary_op -> expression DIVIDE expression
Rule 51    unary_op -> MINUS expression
Rule 52    unary_op -> PLUS expression
Rule 53    unary_op -> NOT expression
Rule 54    type_info -> INT
Rule 55    type_info -> STRING
Rule 56    type_info -> REAL
Rule 57    type_info -> BOOLEAN
Rule 58    type_info -> CHAR

Terminals, with rules where they appear

AND                  : 39
BOOLEAN              : 57
CALL                 : 14 15
CHAR                 : 58
CHARLITERAL          : 
COMMA                : 22 25
COMMENT              : 
DIVEQUALS            : 
DIVIDE               : 50
DO                   : 
EQUALS               : 10 11
FALSE                : 38
FLOAT                : 36
FUNCTION             : 17 18
GE                   : 43
GT                   : 41
ID                   : 10 11 12 13 17 18 23 33
IF                   : 19
INT                  : 54
ISEQUALS             : 45
LBRACKET             : 17 18 19 20
LE                   : 44
LPAREN               : 14 15 17 18
LT                   : 42
MINUS                : 48 51
MINUSEQUALS          : 
MINUSMINUS           : 13
MODULO               : 46
NOT                  : 53
NUMBER               : 34
OR                   : 40
PLUS                 : 47 52
PLUSEQUALS           : 
PLUSPLUS             : 12
RBRACKET             : 17 18 19 20
REAL                 : 56
RETURN               : 16
RPAREN               : 14 15 17 18
SLITERAL             : 35
STRING               : 55
TIMES                : 49
TIMESEQUALS          : 
TRUE                 : 37
WHILE                : 20
error                : 

Nonterminals, with rules where they appear

arguments_list       : 14 25
assignment           : 4
atom                 : 28
binary_op            : 19 20 29
constant             : 32
expression           : 10 11 16 24 25 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 52 53
func_call            : 5 27
func_declaration     : 7
identifier           : 14 15 31
if_statement         : 8
parameter_declaration : 21 22
params_list          : 17 22
program              : 0
return_statement     : 6
simple_expression    : 26
statement            : 2 3
translation_unit     : 1 3 17 18 19 20
type_info            : 11 23
unary_op             : 30
while_statement      : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . translation_unit
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    program                        shift and go to state 8
    statement                      shift and go to state 9
    if_statement                   shift and go to state 10
    translation_unit               shift and go to state 11
    func_declaration               shift and go to state 16

state 1

    (56) type_info -> REAL .

    ID              reduce using rule 56 (type_info -> REAL .)


state 2

    (16) return_statement -> RETURN . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 38

state 3

    (11) assignment -> type_info . ID EQUALS expression

    ID              shift and go to state 39


state 4

    (20) while_statement -> WHILE . binary_op LBRACKET translation_unit RBRACKET
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 40
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 41

state 5

    (19) if_statement -> IF . binary_op LBRACKET translation_unit RBRACKET
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 42
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 41

state 6

    (6) statement -> return_statement .

    RBRACKET        reduce using rule 6 (statement -> return_statement .)
    ID              reduce using rule 6 (statement -> return_statement .)
    CALL            reduce using rule 6 (statement -> return_statement .)
    RETURN          reduce using rule 6 (statement -> return_statement .)
    FUNCTION        reduce using rule 6 (statement -> return_statement .)
    IF              reduce using rule 6 (statement -> return_statement .)
    WHILE           reduce using rule 6 (statement -> return_statement .)
    INT             reduce using rule 6 (statement -> return_statement .)
    STRING          reduce using rule 6 (statement -> return_statement .)
    REAL            reduce using rule 6 (statement -> return_statement .)
    BOOLEAN         reduce using rule 6 (statement -> return_statement .)
    CHAR            reduce using rule 6 (statement -> return_statement .)
    $end            reduce using rule 6 (statement -> return_statement .)


state 7

    (9) statement -> while_statement .

    RBRACKET        reduce using rule 9 (statement -> while_statement .)
    ID              reduce using rule 9 (statement -> while_statement .)
    CALL            reduce using rule 9 (statement -> while_statement .)
    RETURN          reduce using rule 9 (statement -> while_statement .)
    FUNCTION        reduce using rule 9 (statement -> while_statement .)
    IF              reduce using rule 9 (statement -> while_statement .)
    WHILE           reduce using rule 9 (statement -> while_statement .)
    INT             reduce using rule 9 (statement -> while_statement .)
    STRING          reduce using rule 9 (statement -> while_statement .)
    REAL            reduce using rule 9 (statement -> while_statement .)
    BOOLEAN         reduce using rule 9 (statement -> while_statement .)
    CHAR            reduce using rule 9 (statement -> while_statement .)
    $end            reduce using rule 9 (statement -> while_statement .)


state 8

    (0) S' -> program .



state 9

    (2) translation_unit -> statement .

    RBRACKET        reduce using rule 2 (translation_unit -> statement .)
    ID              reduce using rule 2 (translation_unit -> statement .)
    CALL            reduce using rule 2 (translation_unit -> statement .)
    RETURN          reduce using rule 2 (translation_unit -> statement .)
    FUNCTION        reduce using rule 2 (translation_unit -> statement .)
    IF              reduce using rule 2 (translation_unit -> statement .)
    WHILE           reduce using rule 2 (translation_unit -> statement .)
    INT             reduce using rule 2 (translation_unit -> statement .)
    STRING          reduce using rule 2 (translation_unit -> statement .)
    REAL            reduce using rule 2 (translation_unit -> statement .)
    BOOLEAN         reduce using rule 2 (translation_unit -> statement .)
    CHAR            reduce using rule 2 (translation_unit -> statement .)
    $end            reduce using rule 2 (translation_unit -> statement .)


state 10

    (8) statement -> if_statement .

    RBRACKET        reduce using rule 8 (statement -> if_statement .)
    ID              reduce using rule 8 (statement -> if_statement .)
    CALL            reduce using rule 8 (statement -> if_statement .)
    RETURN          reduce using rule 8 (statement -> if_statement .)
    FUNCTION        reduce using rule 8 (statement -> if_statement .)
    IF              reduce using rule 8 (statement -> if_statement .)
    WHILE           reduce using rule 8 (statement -> if_statement .)
    INT             reduce using rule 8 (statement -> if_statement .)
    STRING          reduce using rule 8 (statement -> if_statement .)
    REAL            reduce using rule 8 (statement -> if_statement .)
    BOOLEAN         reduce using rule 8 (statement -> if_statement .)
    CHAR            reduce using rule 8 (statement -> if_statement .)
    $end            reduce using rule 8 (statement -> if_statement .)


state 11

    (1) program -> translation_unit .
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    $end            reduce using rule 1 (program -> translation_unit .)
    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 43
    if_statement                   shift and go to state 10
    func_declaration               shift and go to state 16

state 12

    (17) func_declaration -> FUNCTION . ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> FUNCTION . ID LPAREN RPAREN LBRACKET translation_unit RBRACKET

    ID              shift and go to state 44


state 13

    (55) type_info -> STRING .

    ID              reduce using rule 55 (type_info -> STRING .)


state 14

    (4) statement -> assignment .

    RBRACKET        reduce using rule 4 (statement -> assignment .)
    ID              reduce using rule 4 (statement -> assignment .)
    CALL            reduce using rule 4 (statement -> assignment .)
    RETURN          reduce using rule 4 (statement -> assignment .)
    FUNCTION        reduce using rule 4 (statement -> assignment .)
    IF              reduce using rule 4 (statement -> assignment .)
    WHILE           reduce using rule 4 (statement -> assignment .)
    INT             reduce using rule 4 (statement -> assignment .)
    STRING          reduce using rule 4 (statement -> assignment .)
    REAL            reduce using rule 4 (statement -> assignment .)
    BOOLEAN         reduce using rule 4 (statement -> assignment .)
    CHAR            reduce using rule 4 (statement -> assignment .)
    $end            reduce using rule 4 (statement -> assignment .)


state 15

    (10) assignment -> ID . EQUALS expression
    (12) assignment -> ID . PLUSPLUS
    (13) assignment -> ID . MINUSMINUS

    EQUALS          shift and go to state 47
    PLUSPLUS        shift and go to state 45
    MINUSMINUS      shift and go to state 46


state 16

    (7) statement -> func_declaration .

    RBRACKET        reduce using rule 7 (statement -> func_declaration .)
    ID              reduce using rule 7 (statement -> func_declaration .)
    CALL            reduce using rule 7 (statement -> func_declaration .)
    RETURN          reduce using rule 7 (statement -> func_declaration .)
    FUNCTION        reduce using rule 7 (statement -> func_declaration .)
    IF              reduce using rule 7 (statement -> func_declaration .)
    WHILE           reduce using rule 7 (statement -> func_declaration .)
    INT             reduce using rule 7 (statement -> func_declaration .)
    STRING          reduce using rule 7 (statement -> func_declaration .)
    REAL            reduce using rule 7 (statement -> func_declaration .)
    BOOLEAN         reduce using rule 7 (statement -> func_declaration .)
    CHAR            reduce using rule 7 (statement -> func_declaration .)
    $end            reduce using rule 7 (statement -> func_declaration .)


state 17

    (5) statement -> func_call .

    RBRACKET        reduce using rule 5 (statement -> func_call .)
    ID              reduce using rule 5 (statement -> func_call .)
    CALL            reduce using rule 5 (statement -> func_call .)
    RETURN          reduce using rule 5 (statement -> func_call .)
    FUNCTION        reduce using rule 5 (statement -> func_call .)
    IF              reduce using rule 5 (statement -> func_call .)
    WHILE           reduce using rule 5 (statement -> func_call .)
    INT             reduce using rule 5 (statement -> func_call .)
    STRING          reduce using rule 5 (statement -> func_call .)
    REAL            reduce using rule 5 (statement -> func_call .)
    BOOLEAN         reduce using rule 5 (statement -> func_call .)
    CHAR            reduce using rule 5 (statement -> func_call .)
    $end            reduce using rule 5 (statement -> func_call .)


state 18

    (58) type_info -> CHAR .

    ID              reduce using rule 58 (type_info -> CHAR .)


state 19

    (54) type_info -> INT .

    ID              reduce using rule 54 (type_info -> INT .)


state 20

    (57) type_info -> BOOLEAN .

    ID              reduce using rule 57 (type_info -> BOOLEAN .)


state 21

    (14) func_call -> CALL . identifier LPAREN arguments_list RPAREN
    (15) func_call -> CALL . identifier LPAREN RPAREN
    (33) identifier -> . ID

    ID              shift and go to state 32

    identifier                     shift and go to state 48

state 22

    (34) constant -> NUMBER .

    AND             reduce using rule 34 (constant -> NUMBER .)
    OR              reduce using rule 34 (constant -> NUMBER .)
    GT              reduce using rule 34 (constant -> NUMBER .)
    LT              reduce using rule 34 (constant -> NUMBER .)
    GE              reduce using rule 34 (constant -> NUMBER .)
    LE              reduce using rule 34 (constant -> NUMBER .)
    ISEQUALS        reduce using rule 34 (constant -> NUMBER .)
    MODULO          reduce using rule 34 (constant -> NUMBER .)
    PLUS            reduce using rule 34 (constant -> NUMBER .)
    MINUS           reduce using rule 34 (constant -> NUMBER .)
    TIMES           reduce using rule 34 (constant -> NUMBER .)
    DIVIDE          reduce using rule 34 (constant -> NUMBER .)
    RPAREN          reduce using rule 34 (constant -> NUMBER .)
    COMMA           reduce using rule 34 (constant -> NUMBER .)
    ID              reduce using rule 34 (constant -> NUMBER .)
    CALL            reduce using rule 34 (constant -> NUMBER .)
    RETURN          reduce using rule 34 (constant -> NUMBER .)
    FUNCTION        reduce using rule 34 (constant -> NUMBER .)
    IF              reduce using rule 34 (constant -> NUMBER .)
    WHILE           reduce using rule 34 (constant -> NUMBER .)
    INT             reduce using rule 34 (constant -> NUMBER .)
    STRING          reduce using rule 34 (constant -> NUMBER .)
    REAL            reduce using rule 34 (constant -> NUMBER .)
    BOOLEAN         reduce using rule 34 (constant -> NUMBER .)
    CHAR            reduce using rule 34 (constant -> NUMBER .)
    $end            reduce using rule 34 (constant -> NUMBER .)
    RBRACKET        reduce using rule 34 (constant -> NUMBER .)
    LBRACKET        reduce using rule 34 (constant -> NUMBER .)


state 23

    (30) simple_expression -> unary_op .

    AND             reduce using rule 30 (simple_expression -> unary_op .)
    OR              reduce using rule 30 (simple_expression -> unary_op .)
    GT              reduce using rule 30 (simple_expression -> unary_op .)
    LT              reduce using rule 30 (simple_expression -> unary_op .)
    GE              reduce using rule 30 (simple_expression -> unary_op .)
    LE              reduce using rule 30 (simple_expression -> unary_op .)
    ISEQUALS        reduce using rule 30 (simple_expression -> unary_op .)
    MODULO          reduce using rule 30 (simple_expression -> unary_op .)
    PLUS            reduce using rule 30 (simple_expression -> unary_op .)
    MINUS           reduce using rule 30 (simple_expression -> unary_op .)
    TIMES           reduce using rule 30 (simple_expression -> unary_op .)
    DIVIDE          reduce using rule 30 (simple_expression -> unary_op .)
    ID              reduce using rule 30 (simple_expression -> unary_op .)
    CALL            reduce using rule 30 (simple_expression -> unary_op .)
    RETURN          reduce using rule 30 (simple_expression -> unary_op .)
    FUNCTION        reduce using rule 30 (simple_expression -> unary_op .)
    IF              reduce using rule 30 (simple_expression -> unary_op .)
    WHILE           reduce using rule 30 (simple_expression -> unary_op .)
    INT             reduce using rule 30 (simple_expression -> unary_op .)
    STRING          reduce using rule 30 (simple_expression -> unary_op .)
    REAL            reduce using rule 30 (simple_expression -> unary_op .)
    BOOLEAN         reduce using rule 30 (simple_expression -> unary_op .)
    CHAR            reduce using rule 30 (simple_expression -> unary_op .)
    $end            reduce using rule 30 (simple_expression -> unary_op .)
    RBRACKET        reduce using rule 30 (simple_expression -> unary_op .)
    LBRACKET        reduce using rule 30 (simple_expression -> unary_op .)
    RPAREN          reduce using rule 30 (simple_expression -> unary_op .)
    COMMA           reduce using rule 30 (simple_expression -> unary_op .)


state 24

    (32) atom -> constant .

    AND             reduce using rule 32 (atom -> constant .)
    OR              reduce using rule 32 (atom -> constant .)
    GT              reduce using rule 32 (atom -> constant .)
    LT              reduce using rule 32 (atom -> constant .)
    GE              reduce using rule 32 (atom -> constant .)
    LE              reduce using rule 32 (atom -> constant .)
    ISEQUALS        reduce using rule 32 (atom -> constant .)
    MODULO          reduce using rule 32 (atom -> constant .)
    PLUS            reduce using rule 32 (atom -> constant .)
    MINUS           reduce using rule 32 (atom -> constant .)
    TIMES           reduce using rule 32 (atom -> constant .)
    DIVIDE          reduce using rule 32 (atom -> constant .)
    ID              reduce using rule 32 (atom -> constant .)
    CALL            reduce using rule 32 (atom -> constant .)
    RETURN          reduce using rule 32 (atom -> constant .)
    FUNCTION        reduce using rule 32 (atom -> constant .)
    IF              reduce using rule 32 (atom -> constant .)
    WHILE           reduce using rule 32 (atom -> constant .)
    INT             reduce using rule 32 (atom -> constant .)
    STRING          reduce using rule 32 (atom -> constant .)
    REAL            reduce using rule 32 (atom -> constant .)
    BOOLEAN         reduce using rule 32 (atom -> constant .)
    CHAR            reduce using rule 32 (atom -> constant .)
    $end            reduce using rule 32 (atom -> constant .)
    RBRACKET        reduce using rule 32 (atom -> constant .)
    LBRACKET        reduce using rule 32 (atom -> constant .)
    RPAREN          reduce using rule 32 (atom -> constant .)
    COMMA           reduce using rule 32 (atom -> constant .)


state 25

    (26) expression -> simple_expression .

    AND             reduce using rule 26 (expression -> simple_expression .)
    OR              reduce using rule 26 (expression -> simple_expression .)
    GT              reduce using rule 26 (expression -> simple_expression .)
    LT              reduce using rule 26 (expression -> simple_expression .)
    GE              reduce using rule 26 (expression -> simple_expression .)
    LE              reduce using rule 26 (expression -> simple_expression .)
    ISEQUALS        reduce using rule 26 (expression -> simple_expression .)
    MODULO          reduce using rule 26 (expression -> simple_expression .)
    PLUS            reduce using rule 26 (expression -> simple_expression .)
    MINUS           reduce using rule 26 (expression -> simple_expression .)
    TIMES           reduce using rule 26 (expression -> simple_expression .)
    DIVIDE          reduce using rule 26 (expression -> simple_expression .)
    ID              reduce using rule 26 (expression -> simple_expression .)
    CALL            reduce using rule 26 (expression -> simple_expression .)
    RETURN          reduce using rule 26 (expression -> simple_expression .)
    FUNCTION        reduce using rule 26 (expression -> simple_expression .)
    IF              reduce using rule 26 (expression -> simple_expression .)
    WHILE           reduce using rule 26 (expression -> simple_expression .)
    INT             reduce using rule 26 (expression -> simple_expression .)
    STRING          reduce using rule 26 (expression -> simple_expression .)
    REAL            reduce using rule 26 (expression -> simple_expression .)
    BOOLEAN         reduce using rule 26 (expression -> simple_expression .)
    CHAR            reduce using rule 26 (expression -> simple_expression .)
    $end            reduce using rule 26 (expression -> simple_expression .)
    RBRACKET        reduce using rule 26 (expression -> simple_expression .)
    LBRACKET        reduce using rule 26 (expression -> simple_expression .)
    RPAREN          reduce using rule 26 (expression -> simple_expression .)
    COMMA           reduce using rule 26 (expression -> simple_expression .)


state 26

    (37) constant -> TRUE .

    AND             reduce using rule 37 (constant -> TRUE .)
    OR              reduce using rule 37 (constant -> TRUE .)
    GT              reduce using rule 37 (constant -> TRUE .)
    LT              reduce using rule 37 (constant -> TRUE .)
    GE              reduce using rule 37 (constant -> TRUE .)
    LE              reduce using rule 37 (constant -> TRUE .)
    ISEQUALS        reduce using rule 37 (constant -> TRUE .)
    MODULO          reduce using rule 37 (constant -> TRUE .)
    PLUS            reduce using rule 37 (constant -> TRUE .)
    MINUS           reduce using rule 37 (constant -> TRUE .)
    TIMES           reduce using rule 37 (constant -> TRUE .)
    DIVIDE          reduce using rule 37 (constant -> TRUE .)
    RPAREN          reduce using rule 37 (constant -> TRUE .)
    COMMA           reduce using rule 37 (constant -> TRUE .)
    ID              reduce using rule 37 (constant -> TRUE .)
    CALL            reduce using rule 37 (constant -> TRUE .)
    RETURN          reduce using rule 37 (constant -> TRUE .)
    FUNCTION        reduce using rule 37 (constant -> TRUE .)
    IF              reduce using rule 37 (constant -> TRUE .)
    WHILE           reduce using rule 37 (constant -> TRUE .)
    INT             reduce using rule 37 (constant -> TRUE .)
    STRING          reduce using rule 37 (constant -> TRUE .)
    REAL            reduce using rule 37 (constant -> TRUE .)
    BOOLEAN         reduce using rule 37 (constant -> TRUE .)
    CHAR            reduce using rule 37 (constant -> TRUE .)
    $end            reduce using rule 37 (constant -> TRUE .)
    RBRACKET        reduce using rule 37 (constant -> TRUE .)
    LBRACKET        reduce using rule 37 (constant -> TRUE .)


state 27

    (51) unary_op -> MINUS . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 49

state 28

    (52) unary_op -> PLUS . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 50

state 29

    (35) constant -> SLITERAL .

    AND             reduce using rule 35 (constant -> SLITERAL .)
    OR              reduce using rule 35 (constant -> SLITERAL .)
    GT              reduce using rule 35 (constant -> SLITERAL .)
    LT              reduce using rule 35 (constant -> SLITERAL .)
    GE              reduce using rule 35 (constant -> SLITERAL .)
    LE              reduce using rule 35 (constant -> SLITERAL .)
    ISEQUALS        reduce using rule 35 (constant -> SLITERAL .)
    MODULO          reduce using rule 35 (constant -> SLITERAL .)
    PLUS            reduce using rule 35 (constant -> SLITERAL .)
    MINUS           reduce using rule 35 (constant -> SLITERAL .)
    TIMES           reduce using rule 35 (constant -> SLITERAL .)
    DIVIDE          reduce using rule 35 (constant -> SLITERAL .)
    RPAREN          reduce using rule 35 (constant -> SLITERAL .)
    COMMA           reduce using rule 35 (constant -> SLITERAL .)
    ID              reduce using rule 35 (constant -> SLITERAL .)
    CALL            reduce using rule 35 (constant -> SLITERAL .)
    RETURN          reduce using rule 35 (constant -> SLITERAL .)
    FUNCTION        reduce using rule 35 (constant -> SLITERAL .)
    IF              reduce using rule 35 (constant -> SLITERAL .)
    WHILE           reduce using rule 35 (constant -> SLITERAL .)
    INT             reduce using rule 35 (constant -> SLITERAL .)
    STRING          reduce using rule 35 (constant -> SLITERAL .)
    REAL            reduce using rule 35 (constant -> SLITERAL .)
    BOOLEAN         reduce using rule 35 (constant -> SLITERAL .)
    CHAR            reduce using rule 35 (constant -> SLITERAL .)
    $end            reduce using rule 35 (constant -> SLITERAL .)
    RBRACKET        reduce using rule 35 (constant -> SLITERAL .)
    LBRACKET        reduce using rule 35 (constant -> SLITERAL .)


state 30

    (29) simple_expression -> binary_op .

    AND             reduce using rule 29 (simple_expression -> binary_op .)
    OR              reduce using rule 29 (simple_expression -> binary_op .)
    GT              reduce using rule 29 (simple_expression -> binary_op .)
    LT              reduce using rule 29 (simple_expression -> binary_op .)
    GE              reduce using rule 29 (simple_expression -> binary_op .)
    LE              reduce using rule 29 (simple_expression -> binary_op .)
    ISEQUALS        reduce using rule 29 (simple_expression -> binary_op .)
    MODULO          reduce using rule 29 (simple_expression -> binary_op .)
    PLUS            reduce using rule 29 (simple_expression -> binary_op .)
    MINUS           reduce using rule 29 (simple_expression -> binary_op .)
    TIMES           reduce using rule 29 (simple_expression -> binary_op .)
    DIVIDE          reduce using rule 29 (simple_expression -> binary_op .)
    ID              reduce using rule 29 (simple_expression -> binary_op .)
    CALL            reduce using rule 29 (simple_expression -> binary_op .)
    RETURN          reduce using rule 29 (simple_expression -> binary_op .)
    FUNCTION        reduce using rule 29 (simple_expression -> binary_op .)
    IF              reduce using rule 29 (simple_expression -> binary_op .)
    WHILE           reduce using rule 29 (simple_expression -> binary_op .)
    INT             reduce using rule 29 (simple_expression -> binary_op .)
    STRING          reduce using rule 29 (simple_expression -> binary_op .)
    REAL            reduce using rule 29 (simple_expression -> binary_op .)
    BOOLEAN         reduce using rule 29 (simple_expression -> binary_op .)
    CHAR            reduce using rule 29 (simple_expression -> binary_op .)
    $end            reduce using rule 29 (simple_expression -> binary_op .)
    RBRACKET        reduce using rule 29 (simple_expression -> binary_op .)
    LBRACKET        reduce using rule 29 (simple_expression -> binary_op .)
    RPAREN          reduce using rule 29 (simple_expression -> binary_op .)
    COMMA           reduce using rule 29 (simple_expression -> binary_op .)


state 31

    (28) expression -> atom .

    AND             reduce using rule 28 (expression -> atom .)
    OR              reduce using rule 28 (expression -> atom .)
    GT              reduce using rule 28 (expression -> atom .)
    LT              reduce using rule 28 (expression -> atom .)
    GE              reduce using rule 28 (expression -> atom .)
    LE              reduce using rule 28 (expression -> atom .)
    ISEQUALS        reduce using rule 28 (expression -> atom .)
    MODULO          reduce using rule 28 (expression -> atom .)
    PLUS            reduce using rule 28 (expression -> atom .)
    MINUS           reduce using rule 28 (expression -> atom .)
    TIMES           reduce using rule 28 (expression -> atom .)
    DIVIDE          reduce using rule 28 (expression -> atom .)
    ID              reduce using rule 28 (expression -> atom .)
    CALL            reduce using rule 28 (expression -> atom .)
    RETURN          reduce using rule 28 (expression -> atom .)
    FUNCTION        reduce using rule 28 (expression -> atom .)
    IF              reduce using rule 28 (expression -> atom .)
    WHILE           reduce using rule 28 (expression -> atom .)
    INT             reduce using rule 28 (expression -> atom .)
    STRING          reduce using rule 28 (expression -> atom .)
    REAL            reduce using rule 28 (expression -> atom .)
    BOOLEAN         reduce using rule 28 (expression -> atom .)
    CHAR            reduce using rule 28 (expression -> atom .)
    $end            reduce using rule 28 (expression -> atom .)
    RBRACKET        reduce using rule 28 (expression -> atom .)
    LBRACKET        reduce using rule 28 (expression -> atom .)
    RPAREN          reduce using rule 28 (expression -> atom .)
    COMMA           reduce using rule 28 (expression -> atom .)


state 32

    (33) identifier -> ID .

    AND             reduce using rule 33 (identifier -> ID .)
    OR              reduce using rule 33 (identifier -> ID .)
    GT              reduce using rule 33 (identifier -> ID .)
    LT              reduce using rule 33 (identifier -> ID .)
    GE              reduce using rule 33 (identifier -> ID .)
    LE              reduce using rule 33 (identifier -> ID .)
    ISEQUALS        reduce using rule 33 (identifier -> ID .)
    MODULO          reduce using rule 33 (identifier -> ID .)
    PLUS            reduce using rule 33 (identifier -> ID .)
    MINUS           reduce using rule 33 (identifier -> ID .)
    TIMES           reduce using rule 33 (identifier -> ID .)
    DIVIDE          reduce using rule 33 (identifier -> ID .)
    ID              reduce using rule 33 (identifier -> ID .)
    CALL            reduce using rule 33 (identifier -> ID .)
    RETURN          reduce using rule 33 (identifier -> ID .)
    FUNCTION        reduce using rule 33 (identifier -> ID .)
    IF              reduce using rule 33 (identifier -> ID .)
    WHILE           reduce using rule 33 (identifier -> ID .)
    INT             reduce using rule 33 (identifier -> ID .)
    STRING          reduce using rule 33 (identifier -> ID .)
    REAL            reduce using rule 33 (identifier -> ID .)
    BOOLEAN         reduce using rule 33 (identifier -> ID .)
    CHAR            reduce using rule 33 (identifier -> ID .)
    $end            reduce using rule 33 (identifier -> ID .)
    RBRACKET        reduce using rule 33 (identifier -> ID .)
    LBRACKET        reduce using rule 33 (identifier -> ID .)
    RPAREN          reduce using rule 33 (identifier -> ID .)
    COMMA           reduce using rule 33 (identifier -> ID .)
    LPAREN          reduce using rule 33 (identifier -> ID .)


state 33

    (27) expression -> func_call .

    AND             reduce using rule 27 (expression -> func_call .)
    OR              reduce using rule 27 (expression -> func_call .)
    GT              reduce using rule 27 (expression -> func_call .)
    LT              reduce using rule 27 (expression -> func_call .)
    GE              reduce using rule 27 (expression -> func_call .)
    LE              reduce using rule 27 (expression -> func_call .)
    ISEQUALS        reduce using rule 27 (expression -> func_call .)
    MODULO          reduce using rule 27 (expression -> func_call .)
    PLUS            reduce using rule 27 (expression -> func_call .)
    MINUS           reduce using rule 27 (expression -> func_call .)
    TIMES           reduce using rule 27 (expression -> func_call .)
    DIVIDE          reduce using rule 27 (expression -> func_call .)
    ID              reduce using rule 27 (expression -> func_call .)
    CALL            reduce using rule 27 (expression -> func_call .)
    RETURN          reduce using rule 27 (expression -> func_call .)
    FUNCTION        reduce using rule 27 (expression -> func_call .)
    IF              reduce using rule 27 (expression -> func_call .)
    WHILE           reduce using rule 27 (expression -> func_call .)
    INT             reduce using rule 27 (expression -> func_call .)
    STRING          reduce using rule 27 (expression -> func_call .)
    REAL            reduce using rule 27 (expression -> func_call .)
    BOOLEAN         reduce using rule 27 (expression -> func_call .)
    CHAR            reduce using rule 27 (expression -> func_call .)
    $end            reduce using rule 27 (expression -> func_call .)
    RBRACKET        reduce using rule 27 (expression -> func_call .)
    LBRACKET        reduce using rule 27 (expression -> func_call .)
    RPAREN          reduce using rule 27 (expression -> func_call .)
    COMMA           reduce using rule 27 (expression -> func_call .)


state 34

    (38) constant -> FALSE .

    AND             reduce using rule 38 (constant -> FALSE .)
    OR              reduce using rule 38 (constant -> FALSE .)
    GT              reduce using rule 38 (constant -> FALSE .)
    LT              reduce using rule 38 (constant -> FALSE .)
    GE              reduce using rule 38 (constant -> FALSE .)
    LE              reduce using rule 38 (constant -> FALSE .)
    ISEQUALS        reduce using rule 38 (constant -> FALSE .)
    MODULO          reduce using rule 38 (constant -> FALSE .)
    PLUS            reduce using rule 38 (constant -> FALSE .)
    MINUS           reduce using rule 38 (constant -> FALSE .)
    TIMES           reduce using rule 38 (constant -> FALSE .)
    DIVIDE          reduce using rule 38 (constant -> FALSE .)
    RPAREN          reduce using rule 38 (constant -> FALSE .)
    COMMA           reduce using rule 38 (constant -> FALSE .)
    ID              reduce using rule 38 (constant -> FALSE .)
    CALL            reduce using rule 38 (constant -> FALSE .)
    RETURN          reduce using rule 38 (constant -> FALSE .)
    FUNCTION        reduce using rule 38 (constant -> FALSE .)
    IF              reduce using rule 38 (constant -> FALSE .)
    WHILE           reduce using rule 38 (constant -> FALSE .)
    INT             reduce using rule 38 (constant -> FALSE .)
    STRING          reduce using rule 38 (constant -> FALSE .)
    REAL            reduce using rule 38 (constant -> FALSE .)
    BOOLEAN         reduce using rule 38 (constant -> FALSE .)
    CHAR            reduce using rule 38 (constant -> FALSE .)
    $end            reduce using rule 38 (constant -> FALSE .)
    RBRACKET        reduce using rule 38 (constant -> FALSE .)
    LBRACKET        reduce using rule 38 (constant -> FALSE .)


state 35

    (36) constant -> FLOAT .

    AND             reduce using rule 36 (constant -> FLOAT .)
    OR              reduce using rule 36 (constant -> FLOAT .)
    GT              reduce using rule 36 (constant -> FLOAT .)
    LT              reduce using rule 36 (constant -> FLOAT .)
    GE              reduce using rule 36 (constant -> FLOAT .)
    LE              reduce using rule 36 (constant -> FLOAT .)
    ISEQUALS        reduce using rule 36 (constant -> FLOAT .)
    MODULO          reduce using rule 36 (constant -> FLOAT .)
    PLUS            reduce using rule 36 (constant -> FLOAT .)
    MINUS           reduce using rule 36 (constant -> FLOAT .)
    TIMES           reduce using rule 36 (constant -> FLOAT .)
    DIVIDE          reduce using rule 36 (constant -> FLOAT .)
    RPAREN          reduce using rule 36 (constant -> FLOAT .)
    COMMA           reduce using rule 36 (constant -> FLOAT .)
    ID              reduce using rule 36 (constant -> FLOAT .)
    CALL            reduce using rule 36 (constant -> FLOAT .)
    RETURN          reduce using rule 36 (constant -> FLOAT .)
    FUNCTION        reduce using rule 36 (constant -> FLOAT .)
    IF              reduce using rule 36 (constant -> FLOAT .)
    WHILE           reduce using rule 36 (constant -> FLOAT .)
    INT             reduce using rule 36 (constant -> FLOAT .)
    STRING          reduce using rule 36 (constant -> FLOAT .)
    REAL            reduce using rule 36 (constant -> FLOAT .)
    BOOLEAN         reduce using rule 36 (constant -> FLOAT .)
    CHAR            reduce using rule 36 (constant -> FLOAT .)
    $end            reduce using rule 36 (constant -> FLOAT .)
    RBRACKET        reduce using rule 36 (constant -> FLOAT .)
    LBRACKET        reduce using rule 36 (constant -> FLOAT .)


state 36

    (53) unary_op -> NOT . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 51

state 37

    (31) atom -> identifier .

    AND             reduce using rule 31 (atom -> identifier .)
    OR              reduce using rule 31 (atom -> identifier .)
    GT              reduce using rule 31 (atom -> identifier .)
    LT              reduce using rule 31 (atom -> identifier .)
    GE              reduce using rule 31 (atom -> identifier .)
    LE              reduce using rule 31 (atom -> identifier .)
    ISEQUALS        reduce using rule 31 (atom -> identifier .)
    MODULO          reduce using rule 31 (atom -> identifier .)
    PLUS            reduce using rule 31 (atom -> identifier .)
    MINUS           reduce using rule 31 (atom -> identifier .)
    TIMES           reduce using rule 31 (atom -> identifier .)
    DIVIDE          reduce using rule 31 (atom -> identifier .)
    ID              reduce using rule 31 (atom -> identifier .)
    CALL            reduce using rule 31 (atom -> identifier .)
    RETURN          reduce using rule 31 (atom -> identifier .)
    FUNCTION        reduce using rule 31 (atom -> identifier .)
    IF              reduce using rule 31 (atom -> identifier .)
    WHILE           reduce using rule 31 (atom -> identifier .)
    INT             reduce using rule 31 (atom -> identifier .)
    STRING          reduce using rule 31 (atom -> identifier .)
    REAL            reduce using rule 31 (atom -> identifier .)
    BOOLEAN         reduce using rule 31 (atom -> identifier .)
    CHAR            reduce using rule 31 (atom -> identifier .)
    $end            reduce using rule 31 (atom -> identifier .)
    RBRACKET        reduce using rule 31 (atom -> identifier .)
    LBRACKET        reduce using rule 31 (atom -> identifier .)
    RPAREN          reduce using rule 31 (atom -> identifier .)
    COMMA           reduce using rule 31 (atom -> identifier .)


state 38

    (16) return_statement -> RETURN expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    RBRACKET        reduce using rule 16 (return_statement -> RETURN expression .)
    ID              reduce using rule 16 (return_statement -> RETURN expression .)
    CALL            reduce using rule 16 (return_statement -> RETURN expression .)
    RETURN          reduce using rule 16 (return_statement -> RETURN expression .)
    FUNCTION        reduce using rule 16 (return_statement -> RETURN expression .)
    IF              reduce using rule 16 (return_statement -> RETURN expression .)
    WHILE           reduce using rule 16 (return_statement -> RETURN expression .)
    INT             reduce using rule 16 (return_statement -> RETURN expression .)
    STRING          reduce using rule 16 (return_statement -> RETURN expression .)
    REAL            reduce using rule 16 (return_statement -> RETURN expression .)
    BOOLEAN         reduce using rule 16 (return_statement -> RETURN expression .)
    CHAR            reduce using rule 16 (return_statement -> RETURN expression .)
    $end            reduce using rule 16 (return_statement -> RETURN expression .)
    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54


state 39

    (11) assignment -> type_info ID . EQUALS expression

    EQUALS          shift and go to state 64


state 40

    (20) while_statement -> WHILE binary_op . LBRACKET translation_unit RBRACKET
    (29) simple_expression -> binary_op .

    LBRACKET        shift and go to state 65
    AND             reduce using rule 29 (simple_expression -> binary_op .)
    OR              reduce using rule 29 (simple_expression -> binary_op .)
    GT              reduce using rule 29 (simple_expression -> binary_op .)
    LT              reduce using rule 29 (simple_expression -> binary_op .)
    GE              reduce using rule 29 (simple_expression -> binary_op .)
    LE              reduce using rule 29 (simple_expression -> binary_op .)
    ISEQUALS        reduce using rule 29 (simple_expression -> binary_op .)
    MODULO          reduce using rule 29 (simple_expression -> binary_op .)
    PLUS            reduce using rule 29 (simple_expression -> binary_op .)
    MINUS           reduce using rule 29 (simple_expression -> binary_op .)
    TIMES           reduce using rule 29 (simple_expression -> binary_op .)
    DIVIDE          reduce using rule 29 (simple_expression -> binary_op .)


state 41

    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54


state 42

    (19) if_statement -> IF binary_op . LBRACKET translation_unit RBRACKET
    (29) simple_expression -> binary_op .

    LBRACKET        shift and go to state 66
    AND             reduce using rule 29 (simple_expression -> binary_op .)
    OR              reduce using rule 29 (simple_expression -> binary_op .)
    GT              reduce using rule 29 (simple_expression -> binary_op .)
    LT              reduce using rule 29 (simple_expression -> binary_op .)
    GE              reduce using rule 29 (simple_expression -> binary_op .)
    LE              reduce using rule 29 (simple_expression -> binary_op .)
    ISEQUALS        reduce using rule 29 (simple_expression -> binary_op .)
    MODULO          reduce using rule 29 (simple_expression -> binary_op .)
    PLUS            reduce using rule 29 (simple_expression -> binary_op .)
    MINUS           reduce using rule 29 (simple_expression -> binary_op .)
    TIMES           reduce using rule 29 (simple_expression -> binary_op .)
    DIVIDE          reduce using rule 29 (simple_expression -> binary_op .)


state 43

    (3) translation_unit -> translation_unit statement .

    RBRACKET        reduce using rule 3 (translation_unit -> translation_unit statement .)
    ID              reduce using rule 3 (translation_unit -> translation_unit statement .)
    CALL            reduce using rule 3 (translation_unit -> translation_unit statement .)
    RETURN          reduce using rule 3 (translation_unit -> translation_unit statement .)
    FUNCTION        reduce using rule 3 (translation_unit -> translation_unit statement .)
    IF              reduce using rule 3 (translation_unit -> translation_unit statement .)
    WHILE           reduce using rule 3 (translation_unit -> translation_unit statement .)
    INT             reduce using rule 3 (translation_unit -> translation_unit statement .)
    STRING          reduce using rule 3 (translation_unit -> translation_unit statement .)
    REAL            reduce using rule 3 (translation_unit -> translation_unit statement .)
    BOOLEAN         reduce using rule 3 (translation_unit -> translation_unit statement .)
    CHAR            reduce using rule 3 (translation_unit -> translation_unit statement .)
    $end            reduce using rule 3 (translation_unit -> translation_unit statement .)


state 44

    (17) func_declaration -> FUNCTION ID . LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> FUNCTION ID . LPAREN RPAREN LBRACKET translation_unit RBRACKET

    LPAREN          shift and go to state 67


state 45

    (12) assignment -> ID PLUSPLUS .

    RBRACKET        reduce using rule 12 (assignment -> ID PLUSPLUS .)
    ID              reduce using rule 12 (assignment -> ID PLUSPLUS .)
    CALL            reduce using rule 12 (assignment -> ID PLUSPLUS .)
    RETURN          reduce using rule 12 (assignment -> ID PLUSPLUS .)
    FUNCTION        reduce using rule 12 (assignment -> ID PLUSPLUS .)
    IF              reduce using rule 12 (assignment -> ID PLUSPLUS .)
    WHILE           reduce using rule 12 (assignment -> ID PLUSPLUS .)
    INT             reduce using rule 12 (assignment -> ID PLUSPLUS .)
    STRING          reduce using rule 12 (assignment -> ID PLUSPLUS .)
    REAL            reduce using rule 12 (assignment -> ID PLUSPLUS .)
    BOOLEAN         reduce using rule 12 (assignment -> ID PLUSPLUS .)
    CHAR            reduce using rule 12 (assignment -> ID PLUSPLUS .)
    $end            reduce using rule 12 (assignment -> ID PLUSPLUS .)


state 46

    (13) assignment -> ID MINUSMINUS .

    RBRACKET        reduce using rule 13 (assignment -> ID MINUSMINUS .)
    ID              reduce using rule 13 (assignment -> ID MINUSMINUS .)
    CALL            reduce using rule 13 (assignment -> ID MINUSMINUS .)
    RETURN          reduce using rule 13 (assignment -> ID MINUSMINUS .)
    FUNCTION        reduce using rule 13 (assignment -> ID MINUSMINUS .)
    IF              reduce using rule 13 (assignment -> ID MINUSMINUS .)
    WHILE           reduce using rule 13 (assignment -> ID MINUSMINUS .)
    INT             reduce using rule 13 (assignment -> ID MINUSMINUS .)
    STRING          reduce using rule 13 (assignment -> ID MINUSMINUS .)
    REAL            reduce using rule 13 (assignment -> ID MINUSMINUS .)
    BOOLEAN         reduce using rule 13 (assignment -> ID MINUSMINUS .)
    CHAR            reduce using rule 13 (assignment -> ID MINUSMINUS .)
    $end            reduce using rule 13 (assignment -> ID MINUSMINUS .)


state 47

    (10) assignment -> ID EQUALS . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 68

state 48

    (14) func_call -> CALL identifier . LPAREN arguments_list RPAREN
    (15) func_call -> CALL identifier . LPAREN RPAREN

    LPAREN          shift and go to state 69


state 49

    (51) unary_op -> MINUS expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 51 (unary_op -> MINUS expression .)
    OR              reduce using rule 51 (unary_op -> MINUS expression .)
    GT              reduce using rule 51 (unary_op -> MINUS expression .)
    LT              reduce using rule 51 (unary_op -> MINUS expression .)
    GE              reduce using rule 51 (unary_op -> MINUS expression .)
    LE              reduce using rule 51 (unary_op -> MINUS expression .)
    ISEQUALS        reduce using rule 51 (unary_op -> MINUS expression .)
    PLUS            reduce using rule 51 (unary_op -> MINUS expression .)
    MINUS           reduce using rule 51 (unary_op -> MINUS expression .)
    ID              reduce using rule 51 (unary_op -> MINUS expression .)
    CALL            reduce using rule 51 (unary_op -> MINUS expression .)
    RETURN          reduce using rule 51 (unary_op -> MINUS expression .)
    FUNCTION        reduce using rule 51 (unary_op -> MINUS expression .)
    IF              reduce using rule 51 (unary_op -> MINUS expression .)
    WHILE           reduce using rule 51 (unary_op -> MINUS expression .)
    INT             reduce using rule 51 (unary_op -> MINUS expression .)
    STRING          reduce using rule 51 (unary_op -> MINUS expression .)
    REAL            reduce using rule 51 (unary_op -> MINUS expression .)
    BOOLEAN         reduce using rule 51 (unary_op -> MINUS expression .)
    CHAR            reduce using rule 51 (unary_op -> MINUS expression .)
    $end            reduce using rule 51 (unary_op -> MINUS expression .)
    RBRACKET        reduce using rule 51 (unary_op -> MINUS expression .)
    LBRACKET        reduce using rule 51 (unary_op -> MINUS expression .)
    RPAREN          reduce using rule 51 (unary_op -> MINUS expression .)
    COMMA           reduce using rule 51 (unary_op -> MINUS expression .)
    MODULO          shift and go to state 61
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 51 (unary_op -> MINUS expression .) ]
  ! TIMES           [ reduce using rule 51 (unary_op -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 51 (unary_op -> MINUS expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]
  ! PLUS            [ shift and go to state 60 ]
  ! MINUS           [ shift and go to state 57 ]


state 50

    (52) unary_op -> PLUS expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 52 (unary_op -> PLUS expression .)
    OR              reduce using rule 52 (unary_op -> PLUS expression .)
    GT              reduce using rule 52 (unary_op -> PLUS expression .)
    LT              reduce using rule 52 (unary_op -> PLUS expression .)
    GE              reduce using rule 52 (unary_op -> PLUS expression .)
    LE              reduce using rule 52 (unary_op -> PLUS expression .)
    ISEQUALS        reduce using rule 52 (unary_op -> PLUS expression .)
    PLUS            reduce using rule 52 (unary_op -> PLUS expression .)
    MINUS           reduce using rule 52 (unary_op -> PLUS expression .)
    ID              reduce using rule 52 (unary_op -> PLUS expression .)
    CALL            reduce using rule 52 (unary_op -> PLUS expression .)
    RETURN          reduce using rule 52 (unary_op -> PLUS expression .)
    FUNCTION        reduce using rule 52 (unary_op -> PLUS expression .)
    IF              reduce using rule 52 (unary_op -> PLUS expression .)
    WHILE           reduce using rule 52 (unary_op -> PLUS expression .)
    INT             reduce using rule 52 (unary_op -> PLUS expression .)
    STRING          reduce using rule 52 (unary_op -> PLUS expression .)
    REAL            reduce using rule 52 (unary_op -> PLUS expression .)
    BOOLEAN         reduce using rule 52 (unary_op -> PLUS expression .)
    CHAR            reduce using rule 52 (unary_op -> PLUS expression .)
    $end            reduce using rule 52 (unary_op -> PLUS expression .)
    RBRACKET        reduce using rule 52 (unary_op -> PLUS expression .)
    LBRACKET        reduce using rule 52 (unary_op -> PLUS expression .)
    RPAREN          reduce using rule 52 (unary_op -> PLUS expression .)
    COMMA           reduce using rule 52 (unary_op -> PLUS expression .)
    MODULO          shift and go to state 61
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 52 (unary_op -> PLUS expression .) ]
  ! TIMES           [ reduce using rule 52 (unary_op -> PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 52 (unary_op -> PLUS expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]
  ! PLUS            [ shift and go to state 60 ]
  ! MINUS           [ shift and go to state 57 ]


state 51

    (53) unary_op -> NOT expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for ISEQUALS resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    ID              reduce using rule 53 (unary_op -> NOT expression .)
    CALL            reduce using rule 53 (unary_op -> NOT expression .)
    RETURN          reduce using rule 53 (unary_op -> NOT expression .)
    FUNCTION        reduce using rule 53 (unary_op -> NOT expression .)
    IF              reduce using rule 53 (unary_op -> NOT expression .)
    WHILE           reduce using rule 53 (unary_op -> NOT expression .)
    INT             reduce using rule 53 (unary_op -> NOT expression .)
    STRING          reduce using rule 53 (unary_op -> NOT expression .)
    REAL            reduce using rule 53 (unary_op -> NOT expression .)
    BOOLEAN         reduce using rule 53 (unary_op -> NOT expression .)
    CHAR            reduce using rule 53 (unary_op -> NOT expression .)
    $end            reduce using rule 53 (unary_op -> NOT expression .)
    RBRACKET        reduce using rule 53 (unary_op -> NOT expression .)
    LBRACKET        reduce using rule 53 (unary_op -> NOT expression .)
    RPAREN          reduce using rule 53 (unary_op -> NOT expression .)
    COMMA           reduce using rule 53 (unary_op -> NOT expression .)
    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! AND             [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! OR              [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! GT              [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! LT              [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! GE              [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! LE              [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! ISEQUALS        [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! MODULO          [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! PLUS            [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! MINUS           [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! TIMES           [ reduce using rule 53 (unary_op -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 53 (unary_op -> NOT expression .) ]


state 52

    (39) binary_op -> expression AND . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 70

state 53

    (41) binary_op -> expression GT . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 71

state 54

    (50) binary_op -> expression DIVIDE . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 72

state 55

    (45) binary_op -> expression ISEQUALS . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 73

state 56

    (43) binary_op -> expression GE . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 74

state 57

    (48) binary_op -> expression MINUS . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 75

state 58

    (42) binary_op -> expression LT . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 76

state 59

    (44) binary_op -> expression LE . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 77

state 60

    (47) binary_op -> expression PLUS . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 78

state 61

    (46) binary_op -> expression MODULO . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 79

state 62

    (49) binary_op -> expression TIMES . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 80

state 63

    (40) binary_op -> expression OR . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 81

state 64

    (11) assignment -> type_info ID EQUALS . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 82

state 65

    (20) while_statement -> WHILE binary_op LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 9
    if_statement                   shift and go to state 10
    translation_unit               shift and go to state 83
    func_declaration               shift and go to state 16

state 66

    (19) if_statement -> IF binary_op LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 9
    if_statement                   shift and go to state 10
    translation_unit               shift and go to state 84
    func_declaration               shift and go to state 16

state 67

    (17) func_declaration -> FUNCTION ID LPAREN . params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> FUNCTION ID LPAREN . RPAREN LBRACKET translation_unit RBRACKET
    (21) params_list -> . parameter_declaration
    (22) params_list -> . params_list COMMA parameter_declaration
    (23) parameter_declaration -> . type_info ID
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    RPAREN          shift and go to state 85
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    parameter_declaration          shift and go to state 86
    params_list                    shift and go to state 88
    type_info                      shift and go to state 87

state 68

    (10) assignment -> ID EQUALS expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    RBRACKET        reduce using rule 10 (assignment -> ID EQUALS expression .)
    ID              reduce using rule 10 (assignment -> ID EQUALS expression .)
    CALL            reduce using rule 10 (assignment -> ID EQUALS expression .)
    RETURN          reduce using rule 10 (assignment -> ID EQUALS expression .)
    FUNCTION        reduce using rule 10 (assignment -> ID EQUALS expression .)
    IF              reduce using rule 10 (assignment -> ID EQUALS expression .)
    WHILE           reduce using rule 10 (assignment -> ID EQUALS expression .)
    INT             reduce using rule 10 (assignment -> ID EQUALS expression .)
    STRING          reduce using rule 10 (assignment -> ID EQUALS expression .)
    REAL            reduce using rule 10 (assignment -> ID EQUALS expression .)
    BOOLEAN         reduce using rule 10 (assignment -> ID EQUALS expression .)
    CHAR            reduce using rule 10 (assignment -> ID EQUALS expression .)
    $end            reduce using rule 10 (assignment -> ID EQUALS expression .)
    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54


state 69

    (14) func_call -> CALL identifier LPAREN . arguments_list RPAREN
    (15) func_call -> CALL identifier LPAREN . RPAREN
    (24) arguments_list -> . expression
    (25) arguments_list -> . arguments_list COMMA expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    RPAREN          shift and go to state 90
    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    arguments_list                 shift and go to state 89
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 91

state 70

    (39) binary_op -> expression AND expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 39 (binary_op -> expression AND expression .)
    AND             reduce using rule 39 (binary_op -> expression AND expression .)
    OR              reduce using rule 39 (binary_op -> expression AND expression .)
    ISEQUALS        reduce using rule 39 (binary_op -> expression AND expression .)
    ID              reduce using rule 39 (binary_op -> expression AND expression .)
    CALL            reduce using rule 39 (binary_op -> expression AND expression .)
    RETURN          reduce using rule 39 (binary_op -> expression AND expression .)
    FUNCTION        reduce using rule 39 (binary_op -> expression AND expression .)
    IF              reduce using rule 39 (binary_op -> expression AND expression .)
    WHILE           reduce using rule 39 (binary_op -> expression AND expression .)
    INT             reduce using rule 39 (binary_op -> expression AND expression .)
    STRING          reduce using rule 39 (binary_op -> expression AND expression .)
    REAL            reduce using rule 39 (binary_op -> expression AND expression .)
    BOOLEAN         reduce using rule 39 (binary_op -> expression AND expression .)
    CHAR            reduce using rule 39 (binary_op -> expression AND expression .)
    $end            reduce using rule 39 (binary_op -> expression AND expression .)
    RBRACKET        reduce using rule 39 (binary_op -> expression AND expression .)
    RPAREN          reduce using rule 39 (binary_op -> expression AND expression .)
    COMMA           reduce using rule 39 (binary_op -> expression AND expression .)
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! GT              [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! LT              [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! GE              [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! LE              [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! PLUS            [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 39 (binary_op -> expression AND expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! ISEQUALS        [ shift and go to state 55 ]


state 71

    (41) binary_op -> expression GT expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 41 (binary_op -> expression GT expression .)
    AND             reduce using rule 41 (binary_op -> expression GT expression .)
    OR              reduce using rule 41 (binary_op -> expression GT expression .)
    GT              reduce using rule 41 (binary_op -> expression GT expression .)
    LT              reduce using rule 41 (binary_op -> expression GT expression .)
    GE              reduce using rule 41 (binary_op -> expression GT expression .)
    LE              reduce using rule 41 (binary_op -> expression GT expression .)
    ISEQUALS        reduce using rule 41 (binary_op -> expression GT expression .)
    ID              reduce using rule 41 (binary_op -> expression GT expression .)
    CALL            reduce using rule 41 (binary_op -> expression GT expression .)
    RETURN          reduce using rule 41 (binary_op -> expression GT expression .)
    FUNCTION        reduce using rule 41 (binary_op -> expression GT expression .)
    IF              reduce using rule 41 (binary_op -> expression GT expression .)
    WHILE           reduce using rule 41 (binary_op -> expression GT expression .)
    INT             reduce using rule 41 (binary_op -> expression GT expression .)
    STRING          reduce using rule 41 (binary_op -> expression GT expression .)
    REAL            reduce using rule 41 (binary_op -> expression GT expression .)
    BOOLEAN         reduce using rule 41 (binary_op -> expression GT expression .)
    CHAR            reduce using rule 41 (binary_op -> expression GT expression .)
    $end            reduce using rule 41 (binary_op -> expression GT expression .)
    RBRACKET        reduce using rule 41 (binary_op -> expression GT expression .)
    RPAREN          reduce using rule 41 (binary_op -> expression GT expression .)
    COMMA           reduce using rule 41 (binary_op -> expression GT expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 41 (binary_op -> expression GT expression .) ]
  ! PLUS            [ reduce using rule 41 (binary_op -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 41 (binary_op -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 41 (binary_op -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 41 (binary_op -> expression GT expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]


state 72

    (50) binary_op -> expression DIVIDE expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    AND             reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    OR              reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    GT              reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    LT              reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    GE              reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    LE              reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    ISEQUALS        reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    MODULO          reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    PLUS            reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    MINUS           reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    TIMES           reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    ID              reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    CALL            reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    RETURN          reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    FUNCTION        reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    IF              reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    WHILE           reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    INT             reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    STRING          reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    REAL            reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    BOOLEAN         reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    CHAR            reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    $end            reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    RPAREN          reduce using rule 50 (binary_op -> expression DIVIDE expression .)
    COMMA           reduce using rule 50 (binary_op -> expression DIVIDE expression .)

  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]
  ! MODULO          [ shift and go to state 61 ]
  ! PLUS            [ shift and go to state 60 ]
  ! MINUS           [ shift and go to state 57 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 54 ]


state 73

    (45) binary_op -> expression ISEQUALS expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for ISEQUALS resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    LBRACKET        reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    ID              reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    CALL            reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    RETURN          reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    FUNCTION        reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    IF              reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    WHILE           reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    INT             reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    STRING          reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    REAL            reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    BOOLEAN         reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    CHAR            reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    $end            reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    RBRACKET        reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    RPAREN          reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    COMMA           reduce using rule 45 (binary_op -> expression ISEQUALS expression .)
    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! AND             [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! OR              [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! GT              [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! LT              [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! GE              [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! LE              [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! ISEQUALS        [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! MODULO          [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! PLUS            [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! MINUS           [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! TIMES           [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 45 (binary_op -> expression ISEQUALS expression .) ]


state 74

    (43) binary_op -> expression GE expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 43 (binary_op -> expression GE expression .)
    AND             reduce using rule 43 (binary_op -> expression GE expression .)
    OR              reduce using rule 43 (binary_op -> expression GE expression .)
    GT              reduce using rule 43 (binary_op -> expression GE expression .)
    LT              reduce using rule 43 (binary_op -> expression GE expression .)
    GE              reduce using rule 43 (binary_op -> expression GE expression .)
    LE              reduce using rule 43 (binary_op -> expression GE expression .)
    ISEQUALS        reduce using rule 43 (binary_op -> expression GE expression .)
    ID              reduce using rule 43 (binary_op -> expression GE expression .)
    CALL            reduce using rule 43 (binary_op -> expression GE expression .)
    RETURN          reduce using rule 43 (binary_op -> expression GE expression .)
    FUNCTION        reduce using rule 43 (binary_op -> expression GE expression .)
    IF              reduce using rule 43 (binary_op -> expression GE expression .)
    WHILE           reduce using rule 43 (binary_op -> expression GE expression .)
    INT             reduce using rule 43 (binary_op -> expression GE expression .)
    STRING          reduce using rule 43 (binary_op -> expression GE expression .)
    REAL            reduce using rule 43 (binary_op -> expression GE expression .)
    BOOLEAN         reduce using rule 43 (binary_op -> expression GE expression .)
    CHAR            reduce using rule 43 (binary_op -> expression GE expression .)
    $end            reduce using rule 43 (binary_op -> expression GE expression .)
    RBRACKET        reduce using rule 43 (binary_op -> expression GE expression .)
    RPAREN          reduce using rule 43 (binary_op -> expression GE expression .)
    COMMA           reduce using rule 43 (binary_op -> expression GE expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 43 (binary_op -> expression GE expression .) ]
  ! PLUS            [ reduce using rule 43 (binary_op -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 43 (binary_op -> expression GE expression .) ]
  ! TIMES           [ reduce using rule 43 (binary_op -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 43 (binary_op -> expression GE expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]


state 75

    (48) binary_op -> expression MINUS expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 48 (binary_op -> expression MINUS expression .)
    AND             reduce using rule 48 (binary_op -> expression MINUS expression .)
    OR              reduce using rule 48 (binary_op -> expression MINUS expression .)
    GT              reduce using rule 48 (binary_op -> expression MINUS expression .)
    LT              reduce using rule 48 (binary_op -> expression MINUS expression .)
    GE              reduce using rule 48 (binary_op -> expression MINUS expression .)
    LE              reduce using rule 48 (binary_op -> expression MINUS expression .)
    ISEQUALS        reduce using rule 48 (binary_op -> expression MINUS expression .)
    PLUS            reduce using rule 48 (binary_op -> expression MINUS expression .)
    MINUS           reduce using rule 48 (binary_op -> expression MINUS expression .)
    ID              reduce using rule 48 (binary_op -> expression MINUS expression .)
    CALL            reduce using rule 48 (binary_op -> expression MINUS expression .)
    RETURN          reduce using rule 48 (binary_op -> expression MINUS expression .)
    FUNCTION        reduce using rule 48 (binary_op -> expression MINUS expression .)
    IF              reduce using rule 48 (binary_op -> expression MINUS expression .)
    WHILE           reduce using rule 48 (binary_op -> expression MINUS expression .)
    INT             reduce using rule 48 (binary_op -> expression MINUS expression .)
    STRING          reduce using rule 48 (binary_op -> expression MINUS expression .)
    REAL            reduce using rule 48 (binary_op -> expression MINUS expression .)
    BOOLEAN         reduce using rule 48 (binary_op -> expression MINUS expression .)
    CHAR            reduce using rule 48 (binary_op -> expression MINUS expression .)
    $end            reduce using rule 48 (binary_op -> expression MINUS expression .)
    RBRACKET        reduce using rule 48 (binary_op -> expression MINUS expression .)
    RPAREN          reduce using rule 48 (binary_op -> expression MINUS expression .)
    COMMA           reduce using rule 48 (binary_op -> expression MINUS expression .)
    MODULO          shift and go to state 61
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 48 (binary_op -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 48 (binary_op -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 48 (binary_op -> expression MINUS expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]
  ! PLUS            [ shift and go to state 60 ]
  ! MINUS           [ shift and go to state 57 ]


state 76

    (42) binary_op -> expression LT expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 42 (binary_op -> expression LT expression .)
    AND             reduce using rule 42 (binary_op -> expression LT expression .)
    OR              reduce using rule 42 (binary_op -> expression LT expression .)
    GT              reduce using rule 42 (binary_op -> expression LT expression .)
    LT              reduce using rule 42 (binary_op -> expression LT expression .)
    GE              reduce using rule 42 (binary_op -> expression LT expression .)
    LE              reduce using rule 42 (binary_op -> expression LT expression .)
    ISEQUALS        reduce using rule 42 (binary_op -> expression LT expression .)
    ID              reduce using rule 42 (binary_op -> expression LT expression .)
    CALL            reduce using rule 42 (binary_op -> expression LT expression .)
    RETURN          reduce using rule 42 (binary_op -> expression LT expression .)
    FUNCTION        reduce using rule 42 (binary_op -> expression LT expression .)
    IF              reduce using rule 42 (binary_op -> expression LT expression .)
    WHILE           reduce using rule 42 (binary_op -> expression LT expression .)
    INT             reduce using rule 42 (binary_op -> expression LT expression .)
    STRING          reduce using rule 42 (binary_op -> expression LT expression .)
    REAL            reduce using rule 42 (binary_op -> expression LT expression .)
    BOOLEAN         reduce using rule 42 (binary_op -> expression LT expression .)
    CHAR            reduce using rule 42 (binary_op -> expression LT expression .)
    $end            reduce using rule 42 (binary_op -> expression LT expression .)
    RBRACKET        reduce using rule 42 (binary_op -> expression LT expression .)
    RPAREN          reduce using rule 42 (binary_op -> expression LT expression .)
    COMMA           reduce using rule 42 (binary_op -> expression LT expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 42 (binary_op -> expression LT expression .) ]
  ! PLUS            [ reduce using rule 42 (binary_op -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 42 (binary_op -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 42 (binary_op -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 42 (binary_op -> expression LT expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]


state 77

    (44) binary_op -> expression LE expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 44 (binary_op -> expression LE expression .)
    AND             reduce using rule 44 (binary_op -> expression LE expression .)
    OR              reduce using rule 44 (binary_op -> expression LE expression .)
    GT              reduce using rule 44 (binary_op -> expression LE expression .)
    LT              reduce using rule 44 (binary_op -> expression LE expression .)
    GE              reduce using rule 44 (binary_op -> expression LE expression .)
    LE              reduce using rule 44 (binary_op -> expression LE expression .)
    ISEQUALS        reduce using rule 44 (binary_op -> expression LE expression .)
    ID              reduce using rule 44 (binary_op -> expression LE expression .)
    CALL            reduce using rule 44 (binary_op -> expression LE expression .)
    RETURN          reduce using rule 44 (binary_op -> expression LE expression .)
    FUNCTION        reduce using rule 44 (binary_op -> expression LE expression .)
    IF              reduce using rule 44 (binary_op -> expression LE expression .)
    WHILE           reduce using rule 44 (binary_op -> expression LE expression .)
    INT             reduce using rule 44 (binary_op -> expression LE expression .)
    STRING          reduce using rule 44 (binary_op -> expression LE expression .)
    REAL            reduce using rule 44 (binary_op -> expression LE expression .)
    BOOLEAN         reduce using rule 44 (binary_op -> expression LE expression .)
    CHAR            reduce using rule 44 (binary_op -> expression LE expression .)
    $end            reduce using rule 44 (binary_op -> expression LE expression .)
    RBRACKET        reduce using rule 44 (binary_op -> expression LE expression .)
    RPAREN          reduce using rule 44 (binary_op -> expression LE expression .)
    COMMA           reduce using rule 44 (binary_op -> expression LE expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 44 (binary_op -> expression LE expression .) ]
  ! PLUS            [ reduce using rule 44 (binary_op -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 44 (binary_op -> expression LE expression .) ]
  ! TIMES           [ reduce using rule 44 (binary_op -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 44 (binary_op -> expression LE expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]


state 78

    (47) binary_op -> expression PLUS expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 47 (binary_op -> expression PLUS expression .)
    AND             reduce using rule 47 (binary_op -> expression PLUS expression .)
    OR              reduce using rule 47 (binary_op -> expression PLUS expression .)
    GT              reduce using rule 47 (binary_op -> expression PLUS expression .)
    LT              reduce using rule 47 (binary_op -> expression PLUS expression .)
    GE              reduce using rule 47 (binary_op -> expression PLUS expression .)
    LE              reduce using rule 47 (binary_op -> expression PLUS expression .)
    ISEQUALS        reduce using rule 47 (binary_op -> expression PLUS expression .)
    PLUS            reduce using rule 47 (binary_op -> expression PLUS expression .)
    MINUS           reduce using rule 47 (binary_op -> expression PLUS expression .)
    ID              reduce using rule 47 (binary_op -> expression PLUS expression .)
    CALL            reduce using rule 47 (binary_op -> expression PLUS expression .)
    RETURN          reduce using rule 47 (binary_op -> expression PLUS expression .)
    FUNCTION        reduce using rule 47 (binary_op -> expression PLUS expression .)
    IF              reduce using rule 47 (binary_op -> expression PLUS expression .)
    WHILE           reduce using rule 47 (binary_op -> expression PLUS expression .)
    INT             reduce using rule 47 (binary_op -> expression PLUS expression .)
    STRING          reduce using rule 47 (binary_op -> expression PLUS expression .)
    REAL            reduce using rule 47 (binary_op -> expression PLUS expression .)
    BOOLEAN         reduce using rule 47 (binary_op -> expression PLUS expression .)
    CHAR            reduce using rule 47 (binary_op -> expression PLUS expression .)
    $end            reduce using rule 47 (binary_op -> expression PLUS expression .)
    RBRACKET        reduce using rule 47 (binary_op -> expression PLUS expression .)
    RPAREN          reduce using rule 47 (binary_op -> expression PLUS expression .)
    COMMA           reduce using rule 47 (binary_op -> expression PLUS expression .)
    MODULO          shift and go to state 61
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! MODULO          [ reduce using rule 47 (binary_op -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 47 (binary_op -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 47 (binary_op -> expression PLUS expression .) ]
  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]
  ! PLUS            [ shift and go to state 60 ]
  ! MINUS           [ shift and go to state 57 ]


state 79

    (46) binary_op -> expression MODULO expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 46 (binary_op -> expression MODULO expression .)
    AND             reduce using rule 46 (binary_op -> expression MODULO expression .)
    OR              reduce using rule 46 (binary_op -> expression MODULO expression .)
    GT              reduce using rule 46 (binary_op -> expression MODULO expression .)
    LT              reduce using rule 46 (binary_op -> expression MODULO expression .)
    GE              reduce using rule 46 (binary_op -> expression MODULO expression .)
    LE              reduce using rule 46 (binary_op -> expression MODULO expression .)
    ISEQUALS        reduce using rule 46 (binary_op -> expression MODULO expression .)
    MODULO          reduce using rule 46 (binary_op -> expression MODULO expression .)
    PLUS            reduce using rule 46 (binary_op -> expression MODULO expression .)
    MINUS           reduce using rule 46 (binary_op -> expression MODULO expression .)
    TIMES           reduce using rule 46 (binary_op -> expression MODULO expression .)
    DIVIDE          reduce using rule 46 (binary_op -> expression MODULO expression .)
    ID              reduce using rule 46 (binary_op -> expression MODULO expression .)
    CALL            reduce using rule 46 (binary_op -> expression MODULO expression .)
    RETURN          reduce using rule 46 (binary_op -> expression MODULO expression .)
    FUNCTION        reduce using rule 46 (binary_op -> expression MODULO expression .)
    IF              reduce using rule 46 (binary_op -> expression MODULO expression .)
    WHILE           reduce using rule 46 (binary_op -> expression MODULO expression .)
    INT             reduce using rule 46 (binary_op -> expression MODULO expression .)
    STRING          reduce using rule 46 (binary_op -> expression MODULO expression .)
    REAL            reduce using rule 46 (binary_op -> expression MODULO expression .)
    BOOLEAN         reduce using rule 46 (binary_op -> expression MODULO expression .)
    CHAR            reduce using rule 46 (binary_op -> expression MODULO expression .)
    $end            reduce using rule 46 (binary_op -> expression MODULO expression .)
    RBRACKET        reduce using rule 46 (binary_op -> expression MODULO expression .)
    RPAREN          reduce using rule 46 (binary_op -> expression MODULO expression .)
    COMMA           reduce using rule 46 (binary_op -> expression MODULO expression .)

  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]
  ! MODULO          [ shift and go to state 61 ]
  ! PLUS            [ shift and go to state 60 ]
  ! MINUS           [ shift and go to state 57 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 54 ]


state 80

    (49) binary_op -> expression TIMES expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 49 (binary_op -> expression TIMES expression .)
    AND             reduce using rule 49 (binary_op -> expression TIMES expression .)
    OR              reduce using rule 49 (binary_op -> expression TIMES expression .)
    GT              reduce using rule 49 (binary_op -> expression TIMES expression .)
    LT              reduce using rule 49 (binary_op -> expression TIMES expression .)
    GE              reduce using rule 49 (binary_op -> expression TIMES expression .)
    LE              reduce using rule 49 (binary_op -> expression TIMES expression .)
    ISEQUALS        reduce using rule 49 (binary_op -> expression TIMES expression .)
    MODULO          reduce using rule 49 (binary_op -> expression TIMES expression .)
    PLUS            reduce using rule 49 (binary_op -> expression TIMES expression .)
    MINUS           reduce using rule 49 (binary_op -> expression TIMES expression .)
    TIMES           reduce using rule 49 (binary_op -> expression TIMES expression .)
    DIVIDE          reduce using rule 49 (binary_op -> expression TIMES expression .)
    ID              reduce using rule 49 (binary_op -> expression TIMES expression .)
    CALL            reduce using rule 49 (binary_op -> expression TIMES expression .)
    RETURN          reduce using rule 49 (binary_op -> expression TIMES expression .)
    FUNCTION        reduce using rule 49 (binary_op -> expression TIMES expression .)
    IF              reduce using rule 49 (binary_op -> expression TIMES expression .)
    WHILE           reduce using rule 49 (binary_op -> expression TIMES expression .)
    INT             reduce using rule 49 (binary_op -> expression TIMES expression .)
    STRING          reduce using rule 49 (binary_op -> expression TIMES expression .)
    REAL            reduce using rule 49 (binary_op -> expression TIMES expression .)
    BOOLEAN         reduce using rule 49 (binary_op -> expression TIMES expression .)
    CHAR            reduce using rule 49 (binary_op -> expression TIMES expression .)
    $end            reduce using rule 49 (binary_op -> expression TIMES expression .)
    RBRACKET        reduce using rule 49 (binary_op -> expression TIMES expression .)
    RPAREN          reduce using rule 49 (binary_op -> expression TIMES expression .)
    COMMA           reduce using rule 49 (binary_op -> expression TIMES expression .)

  ! AND             [ shift and go to state 52 ]
  ! OR              [ shift and go to state 63 ]
  ! GT              [ shift and go to state 53 ]
  ! LT              [ shift and go to state 58 ]
  ! GE              [ shift and go to state 56 ]
  ! LE              [ shift and go to state 59 ]
  ! ISEQUALS        [ shift and go to state 55 ]
  ! MODULO          [ shift and go to state 61 ]
  ! PLUS            [ shift and go to state 60 ]
  ! MINUS           [ shift and go to state 57 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 54 ]


state 81

    (40) binary_op -> expression OR expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    LBRACKET        reduce using rule 40 (binary_op -> expression OR expression .)
    OR              reduce using rule 40 (binary_op -> expression OR expression .)
    ISEQUALS        reduce using rule 40 (binary_op -> expression OR expression .)
    ID              reduce using rule 40 (binary_op -> expression OR expression .)
    CALL            reduce using rule 40 (binary_op -> expression OR expression .)
    RETURN          reduce using rule 40 (binary_op -> expression OR expression .)
    FUNCTION        reduce using rule 40 (binary_op -> expression OR expression .)
    IF              reduce using rule 40 (binary_op -> expression OR expression .)
    WHILE           reduce using rule 40 (binary_op -> expression OR expression .)
    INT             reduce using rule 40 (binary_op -> expression OR expression .)
    STRING          reduce using rule 40 (binary_op -> expression OR expression .)
    REAL            reduce using rule 40 (binary_op -> expression OR expression .)
    BOOLEAN         reduce using rule 40 (binary_op -> expression OR expression .)
    CHAR            reduce using rule 40 (binary_op -> expression OR expression .)
    $end            reduce using rule 40 (binary_op -> expression OR expression .)
    RBRACKET        reduce using rule 40 (binary_op -> expression OR expression .)
    RPAREN          reduce using rule 40 (binary_op -> expression OR expression .)
    COMMA           reduce using rule 40 (binary_op -> expression OR expression .)
    AND             shift and go to state 52
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54

  ! AND             [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! GT              [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! LT              [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! GE              [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! LE              [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! PLUS            [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 40 (binary_op -> expression OR expression .) ]
  ! OR              [ shift and go to state 63 ]
  ! ISEQUALS        [ shift and go to state 55 ]


state 82

    (11) assignment -> type_info ID EQUALS expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    RBRACKET        reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    ID              reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    CALL            reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    RETURN          reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    FUNCTION        reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    IF              reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    WHILE           reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    INT             reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    STRING          reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    REAL            reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    BOOLEAN         reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    CHAR            reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    $end            reduce using rule 11 (assignment -> type_info ID EQUALS expression .)
    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54


state 83

    (20) while_statement -> WHILE binary_op LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    RBRACKET        shift and go to state 92
    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 43
    if_statement                   shift and go to state 10
    func_declaration               shift and go to state 16

state 84

    (19) if_statement -> IF binary_op LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    RBRACKET        shift and go to state 93
    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 43
    if_statement                   shift and go to state 10
    func_declaration               shift and go to state 16

state 85

    (18) func_declaration -> FUNCTION ID LPAREN RPAREN . LBRACKET translation_unit RBRACKET

    LBRACKET        shift and go to state 94


state 86

    (21) params_list -> parameter_declaration .

    RPAREN          reduce using rule 21 (params_list -> parameter_declaration .)
    COMMA           reduce using rule 21 (params_list -> parameter_declaration .)


state 87

    (23) parameter_declaration -> type_info . ID

    ID              shift and go to state 95


state 88

    (17) func_declaration -> FUNCTION ID LPAREN params_list . RPAREN LBRACKET translation_unit RBRACKET
    (22) params_list -> params_list . COMMA parameter_declaration

    RPAREN          shift and go to state 96
    COMMA           shift and go to state 97


state 89

    (14) func_call -> CALL identifier LPAREN arguments_list . RPAREN
    (25) arguments_list -> arguments_list . COMMA expression

    RPAREN          shift and go to state 98
    COMMA           shift and go to state 99


state 90

    (15) func_call -> CALL identifier LPAREN RPAREN .

    RBRACKET        reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    ID              reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    CALL            reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    RETURN          reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    FUNCTION        reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    IF              reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    WHILE           reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    INT             reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    STRING          reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    REAL            reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    BOOLEAN         reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    CHAR            reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    AND             reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    OR              reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    GT              reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    LT              reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    GE              reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    LE              reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    ISEQUALS        reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    MODULO          reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    PLUS            reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    MINUS           reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    TIMES           reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    DIVIDE          reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    $end            reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    LBRACKET        reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    RPAREN          reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)
    COMMA           reduce using rule 15 (func_call -> CALL identifier LPAREN RPAREN .)


state 91

    (24) arguments_list -> expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    RPAREN          reduce using rule 24 (arguments_list -> expression .)
    COMMA           reduce using rule 24 (arguments_list -> expression .)
    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54


state 92

    (20) while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .

    RBRACKET        reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 20 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)


state 93

    (19) if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .

    RBRACKET        reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 19 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)


state 94

    (18) func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 9
    if_statement                   shift and go to state 10
    translation_unit               shift and go to state 100
    func_declaration               shift and go to state 16

state 95

    (23) parameter_declaration -> type_info ID .

    RPAREN          reduce using rule 23 (parameter_declaration -> type_info ID .)
    COMMA           reduce using rule 23 (parameter_declaration -> type_info ID .)


state 96

    (17) func_declaration -> FUNCTION ID LPAREN params_list RPAREN . LBRACKET translation_unit RBRACKET

    LBRACKET        shift and go to state 101


state 97

    (22) params_list -> params_list COMMA . parameter_declaration
    (23) parameter_declaration -> . type_info ID
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    parameter_declaration          shift and go to state 102
    type_info                      shift and go to state 87

state 98

    (14) func_call -> CALL identifier LPAREN arguments_list RPAREN .

    RBRACKET        reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    ID              reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    CALL            reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    RETURN          reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    FUNCTION        reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    IF              reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    WHILE           reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    INT             reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    STRING          reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    REAL            reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    BOOLEAN         reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    CHAR            reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    AND             reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    OR              reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    GT              reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    LT              reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    GE              reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    LE              reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    ISEQUALS        reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    MODULO          reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    PLUS            reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    MINUS           reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    TIMES           reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    DIVIDE          reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    $end            reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    LBRACKET        reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    RPAREN          reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    COMMA           reduce using rule 14 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)


state 99

    (25) arguments_list -> arguments_list COMMA . expression
    (26) expression -> . simple_expression
    (27) expression -> . func_call
    (28) expression -> . atom
    (29) simple_expression -> . binary_op
    (30) simple_expression -> . unary_op
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (31) atom -> . identifier
    (32) atom -> . constant
    (39) binary_op -> . expression AND expression
    (40) binary_op -> . expression OR expression
    (41) binary_op -> . expression GT expression
    (42) binary_op -> . expression LT expression
    (43) binary_op -> . expression GE expression
    (44) binary_op -> . expression LE expression
    (45) binary_op -> . expression ISEQUALS expression
    (46) binary_op -> . expression MODULO expression
    (47) binary_op -> . expression PLUS expression
    (48) binary_op -> . expression MINUS expression
    (49) binary_op -> . expression TIMES expression
    (50) binary_op -> . expression DIVIDE expression
    (51) unary_op -> . MINUS expression
    (52) unary_op -> . PLUS expression
    (53) unary_op -> . NOT expression
    (33) identifier -> . ID
    (34) constant -> . NUMBER
    (35) constant -> . SLITERAL
    (36) constant -> . FLOAT
    (37) constant -> . TRUE
    (38) constant -> . FALSE

    CALL            shift and go to state 21
    MINUS           shift and go to state 27
    PLUS            shift and go to state 28
    NOT             shift and go to state 36
    ID              shift and go to state 32
    NUMBER          shift and go to state 22
    SLITERAL        shift and go to state 29
    FLOAT           shift and go to state 35
    TRUE            shift and go to state 26
    FALSE           shift and go to state 34

    func_call                      shift and go to state 33
    constant                       shift and go to state 24
    binary_op                      shift and go to state 30
    unary_op                       shift and go to state 23
    atom                           shift and go to state 31
    simple_expression              shift and go to state 25
    identifier                     shift and go to state 37
    expression                     shift and go to state 103

state 100

    (18) func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    RBRACKET        shift and go to state 104
    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 43
    if_statement                   shift and go to state 10
    func_declaration               shift and go to state 16

state 101

    (17) func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 9
    if_statement                   shift and go to state 10
    translation_unit               shift and go to state 105
    func_declaration               shift and go to state 16

state 102

    (22) params_list -> params_list COMMA parameter_declaration .

    RPAREN          reduce using rule 22 (params_list -> params_list COMMA parameter_declaration .)
    COMMA           reduce using rule 22 (params_list -> params_list COMMA parameter_declaration .)


state 103

    (25) arguments_list -> arguments_list COMMA expression .
    (39) binary_op -> expression . AND expression
    (40) binary_op -> expression . OR expression
    (41) binary_op -> expression . GT expression
    (42) binary_op -> expression . LT expression
    (43) binary_op -> expression . GE expression
    (44) binary_op -> expression . LE expression
    (45) binary_op -> expression . ISEQUALS expression
    (46) binary_op -> expression . MODULO expression
    (47) binary_op -> expression . PLUS expression
    (48) binary_op -> expression . MINUS expression
    (49) binary_op -> expression . TIMES expression
    (50) binary_op -> expression . DIVIDE expression

    RPAREN          reduce using rule 25 (arguments_list -> arguments_list COMMA expression .)
    COMMA           reduce using rule 25 (arguments_list -> arguments_list COMMA expression .)
    AND             shift and go to state 52
    OR              shift and go to state 63
    GT              shift and go to state 53
    LT              shift and go to state 58
    GE              shift and go to state 56
    LE              shift and go to state 59
    ISEQUALS        shift and go to state 55
    MODULO          shift and go to state 61
    PLUS            shift and go to state 60
    MINUS           shift and go to state 57
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 54


state 104

    (18) func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .

    RBRACKET        reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 18 (func_declaration -> FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET .)


state 105

    (17) func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) assignment -> . ID EQUALS expression
    (11) assignment -> . type_info ID EQUALS expression
    (12) assignment -> . ID PLUSPLUS
    (13) assignment -> . ID MINUSMINUS
    (14) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (15) func_call -> . CALL identifier LPAREN RPAREN
    (16) return_statement -> . RETURN expression
    (17) func_declaration -> . FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET
    (18) func_declaration -> . FUNCTION ID LPAREN RPAREN LBRACKET translation_unit RBRACKET
    (19) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (20) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (54) type_info -> . INT
    (55) type_info -> . STRING
    (56) type_info -> . REAL
    (57) type_info -> . BOOLEAN
    (58) type_info -> . CHAR

    RBRACKET        shift and go to state 106
    ID              shift and go to state 15
    CALL            shift and go to state 21
    RETURN          shift and go to state 2
    FUNCTION        shift and go to state 12
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    INT             shift and go to state 19
    STRING          shift and go to state 13
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 20
    CHAR            shift and go to state 18

    func_call                      shift and go to state 17
    assignment                     shift and go to state 14
    type_info                      shift and go to state 3
    return_statement               shift and go to state 6
    while_statement                shift and go to state 7
    statement                      shift and go to state 43
    if_statement                   shift and go to state 10
    func_declaration               shift and go to state 16

state 106

    (17) func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .

    RBRACKET        reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 17 (func_declaration -> FUNCTION ID LPAREN params_list RPAREN LBRACKET translation_unit RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 51 resolved as shift
WARNING: shift/reduce conflict for OR in state 51 resolved as shift
WARNING: shift/reduce conflict for GT in state 51 resolved as shift
WARNING: shift/reduce conflict for LT in state 51 resolved as shift
WARNING: shift/reduce conflict for GE in state 51 resolved as shift
WARNING: shift/reduce conflict for LE in state 51 resolved as shift
WARNING: shift/reduce conflict for ISEQUALS in state 51 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 51 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 51 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 51 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 51 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 51 resolved as shift
WARNING: shift/reduce conflict for AND in state 73 resolved as shift
WARNING: shift/reduce conflict for OR in state 73 resolved as shift
WARNING: shift/reduce conflict for GT in state 73 resolved as shift
WARNING: shift/reduce conflict for LT in state 73 resolved as shift
WARNING: shift/reduce conflict for GE in state 73 resolved as shift
WARNING: shift/reduce conflict for LE in state 73 resolved as shift
WARNING: shift/reduce conflict for ISEQUALS in state 73 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 73 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 73 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 73 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 73 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 73 resolved as shift
