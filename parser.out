Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    COMMENT
    CHARLITERAL
    TIMESEQUALS
    DIVEQUALS
    PLUSEQUALS
    MINUSEQUALS

Grammar

Rule 0     S' -> program
Rule 1     program -> translation_unit
Rule 2     translation_unit -> statement
Rule 3     translation_unit -> translation_unit statement
Rule 4     statement -> assignment
Rule 5     statement -> func_call
Rule 6     statement -> return_statement
Rule 7     statement -> func_declaration
Rule 8     statement -> if_statement
Rule 9     statement -> while_statement
Rule 10    statement -> for_statement
Rule 11    assignment -> identifier EQUALS expression
Rule 12    assignment -> type_info identifier EQUALS expression
Rule 13    assignment -> CONST type_info identifier EQUALS value
Rule 14    assignment -> ID PLUSPLUS
Rule 15    assignment -> ID MINUSMINUS
Rule 16    func_call -> CALL identifier LPAREN arguments_list RPAREN
Rule 17    func_call -> CALL identifier LPAREN RPAREN
Rule 18    func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
Rule 19    func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
Rule 20    return_statement -> RETURN expression
Rule 21    if_statement -> IF binary_op LBRACKET translation_unit RBRACKET
Rule 22    else_statement -> ELSE LBRACKET translation_unit RBRACKET
Rule 23    while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET
Rule 24    for_statement -> FOR ID IN ID
Rule 25    for_statement -> FOR ID IN func_call
Rule 26    params_list -> parameter_declaration
Rule 27    params_list -> params_list COMMA parameter_declaration
Rule 28    parameter_declaration -> type_info identifier
Rule 29    arguments_list -> expression
Rule 30    arguments_list -> arguments_list COMMA expression
Rule 31    expression -> simple_expression
Rule 32    expression -> func_call
Rule 33    expression -> atom
Rule 34    simple_expression -> binary_op
Rule 35    simple_expression -> unary_op
Rule 36    atom -> identifier
Rule 37    atom -> value
Rule 38    identifier -> ID
Rule 39    value -> NUMBER
Rule 40    value -> SLITERAL
Rule 41    value -> FLOAT
Rule 42    value -> TRUE
Rule 43    value -> FALSE
Rule 44    binary_op -> expression AND expression
Rule 45    binary_op -> expression OR expression
Rule 46    binary_op -> expression GT expression
Rule 47    binary_op -> expression LT expression
Rule 48    binary_op -> expression GE expression
Rule 49    binary_op -> expression LE expression
Rule 50    binary_op -> expression ISEQUALS expression
Rule 51    binary_op -> expression MODULO expression
Rule 52    binary_op -> expression PLUS expression
Rule 53    binary_op -> expression MINUS expression
Rule 54    binary_op -> expression TIMES expression
Rule 55    binary_op -> expression DIVIDE expression
Rule 56    unary_op -> MINUS expression
Rule 57    unary_op -> NOT expression
Rule 58    type_info -> INT
Rule 59    type_info -> STRING
Rule 60    type_info -> REAL
Rule 61    type_info -> BOOLEAN
Rule 62    type_info -> CHAR

Terminals, with rules where they appear

AND                  : 44
BOOLEAN              : 61
CALL                 : 16 17
CHAR                 : 62
CHARLITERAL          : 
COLON                : 18 19
COMMA                : 27 30
COMMENT              : 
CONST                : 13
DIVEQUALS            : 
DIVIDE               : 55
DO                   : 
ELSE                 : 22
EQUALS               : 11 12 13
FALSE                : 43
FLOAT                : 41
FOR                  : 24 25
FUNCTION             : 18 19
GE                   : 48
GT                   : 46
ID                   : 14 15 24 24 25 38
IF                   : 21
IN                   : 24 25
INT                  : 58
ISEQUALS             : 50
LBRACKET             : 18 19 21 22 23
LE                   : 49
LPAREN               : 16 17 18 19
LT                   : 47
MINUS                : 53 56
MINUSEQUALS          : 
MINUSMINUS           : 15
MODULO               : 51
NOT                  : 57
NUMBER               : 39
OR                   : 45
PLUS                 : 52
PLUSEQUALS           : 
PLUSPLUS             : 14
RBRACKET             : 18 19 21 22 23
REAL                 : 60
RETURN               : 20
RETURNS              : 18 19
RPAREN               : 16 17 18 19
SLITERAL             : 40
STRING               : 59
TIMES                : 54
TIMESEQUALS          : 
TRUE                 : 42
WHILE                : 23
error                : 

Nonterminals, with rules where they appear

arguments_list       : 16 30
assignment           : 4
atom                 : 33
binary_op            : 21 23 34
else_statement       : 
expression           : 11 12 20 29 30 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 57
for_statement        : 10
func_call            : 5 25 32
func_declaration     : 7
identifier           : 11 12 13 16 17 18 19 28 36
if_statement         : 8
parameter_declaration : 26 27
params_list          : 18 27
program              : 0
return_statement     : 6
simple_expression    : 31
statement            : 2 3
translation_unit     : 1 3 18 19 21 22 23
type_info            : 12 13 18 19 28
unary_op             : 35
value                : 13 37
while_statement      : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . translation_unit
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    identifier                     shift and go to state 25
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    program                        shift and go to state 9
    statement                      shift and go to state 10
    if_statement                   shift and go to state 11
    translation_unit               shift and go to state 12
    func_declaration               shift and go to state 19

state 1

    (60) type_info -> REAL .

    ID              reduce using rule 60 (type_info -> REAL .)
    LBRACKET        reduce using rule 60 (type_info -> REAL .)


state 2

    (13) assignment -> CONST . type_info identifier EQUALS value
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    type_info                      shift and go to state 26

state 3

    (12) assignment -> type_info . identifier EQUALS expression
    (38) identifier -> . ID

    ID              shift and go to state 28

    identifier                     shift and go to state 27

state 4

    (23) while_statement -> WHILE . binary_op LBRACKET translation_unit RBRACKET
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 36
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 43

state 5

    (21) if_statement -> IF . binary_op LBRACKET translation_unit RBRACKET
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 44
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 43

state 6

    (20) return_statement -> RETURN . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 46

state 7

    (6) statement -> return_statement .

    RBRACKET        reduce using rule 6 (statement -> return_statement .)
    CONST           reduce using rule 6 (statement -> return_statement .)
    ID              reduce using rule 6 (statement -> return_statement .)
    CALL            reduce using rule 6 (statement -> return_statement .)
    RETURN          reduce using rule 6 (statement -> return_statement .)
    FUNCTION        reduce using rule 6 (statement -> return_statement .)
    IF              reduce using rule 6 (statement -> return_statement .)
    WHILE           reduce using rule 6 (statement -> return_statement .)
    FOR             reduce using rule 6 (statement -> return_statement .)
    INT             reduce using rule 6 (statement -> return_statement .)
    STRING          reduce using rule 6 (statement -> return_statement .)
    REAL            reduce using rule 6 (statement -> return_statement .)
    BOOLEAN         reduce using rule 6 (statement -> return_statement .)
    CHAR            reduce using rule 6 (statement -> return_statement .)
    $end            reduce using rule 6 (statement -> return_statement .)


state 8

    (9) statement -> while_statement .

    RBRACKET        reduce using rule 9 (statement -> while_statement .)
    CONST           reduce using rule 9 (statement -> while_statement .)
    ID              reduce using rule 9 (statement -> while_statement .)
    CALL            reduce using rule 9 (statement -> while_statement .)
    RETURN          reduce using rule 9 (statement -> while_statement .)
    FUNCTION        reduce using rule 9 (statement -> while_statement .)
    IF              reduce using rule 9 (statement -> while_statement .)
    WHILE           reduce using rule 9 (statement -> while_statement .)
    FOR             reduce using rule 9 (statement -> while_statement .)
    INT             reduce using rule 9 (statement -> while_statement .)
    STRING          reduce using rule 9 (statement -> while_statement .)
    REAL            reduce using rule 9 (statement -> while_statement .)
    BOOLEAN         reduce using rule 9 (statement -> while_statement .)
    CHAR            reduce using rule 9 (statement -> while_statement .)
    $end            reduce using rule 9 (statement -> while_statement .)


state 9

    (0) S' -> program .



state 10

    (2) translation_unit -> statement .

    RBRACKET        reduce using rule 2 (translation_unit -> statement .)
    CONST           reduce using rule 2 (translation_unit -> statement .)
    ID              reduce using rule 2 (translation_unit -> statement .)
    CALL            reduce using rule 2 (translation_unit -> statement .)
    RETURN          reduce using rule 2 (translation_unit -> statement .)
    FUNCTION        reduce using rule 2 (translation_unit -> statement .)
    IF              reduce using rule 2 (translation_unit -> statement .)
    WHILE           reduce using rule 2 (translation_unit -> statement .)
    FOR             reduce using rule 2 (translation_unit -> statement .)
    INT             reduce using rule 2 (translation_unit -> statement .)
    STRING          reduce using rule 2 (translation_unit -> statement .)
    REAL            reduce using rule 2 (translation_unit -> statement .)
    BOOLEAN         reduce using rule 2 (translation_unit -> statement .)
    CHAR            reduce using rule 2 (translation_unit -> statement .)
    $end            reduce using rule 2 (translation_unit -> statement .)


state 11

    (8) statement -> if_statement .

    RBRACKET        reduce using rule 8 (statement -> if_statement .)
    CONST           reduce using rule 8 (statement -> if_statement .)
    ID              reduce using rule 8 (statement -> if_statement .)
    CALL            reduce using rule 8 (statement -> if_statement .)
    RETURN          reduce using rule 8 (statement -> if_statement .)
    FUNCTION        reduce using rule 8 (statement -> if_statement .)
    IF              reduce using rule 8 (statement -> if_statement .)
    WHILE           reduce using rule 8 (statement -> if_statement .)
    FOR             reduce using rule 8 (statement -> if_statement .)
    INT             reduce using rule 8 (statement -> if_statement .)
    STRING          reduce using rule 8 (statement -> if_statement .)
    REAL            reduce using rule 8 (statement -> if_statement .)
    BOOLEAN         reduce using rule 8 (statement -> if_statement .)
    CHAR            reduce using rule 8 (statement -> if_statement .)
    $end            reduce using rule 8 (statement -> if_statement .)


state 12

    (1) program -> translation_unit .
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    $end            reduce using rule 1 (program -> translation_unit .)
    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    identifier                     shift and go to state 25
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 47
    if_statement                   shift and go to state 11
    func_declaration               shift and go to state 19

state 13

    (18) func_declaration -> FUNCTION . identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> FUNCTION . identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (38) identifier -> . ID

    ID              shift and go to state 28

    identifier                     shift and go to state 48

state 14

    (10) statement -> for_statement .

    RBRACKET        reduce using rule 10 (statement -> for_statement .)
    CONST           reduce using rule 10 (statement -> for_statement .)
    ID              reduce using rule 10 (statement -> for_statement .)
    CALL            reduce using rule 10 (statement -> for_statement .)
    RETURN          reduce using rule 10 (statement -> for_statement .)
    FUNCTION        reduce using rule 10 (statement -> for_statement .)
    IF              reduce using rule 10 (statement -> for_statement .)
    WHILE           reduce using rule 10 (statement -> for_statement .)
    FOR             reduce using rule 10 (statement -> for_statement .)
    INT             reduce using rule 10 (statement -> for_statement .)
    STRING          reduce using rule 10 (statement -> for_statement .)
    REAL            reduce using rule 10 (statement -> for_statement .)
    BOOLEAN         reduce using rule 10 (statement -> for_statement .)
    CHAR            reduce using rule 10 (statement -> for_statement .)
    $end            reduce using rule 10 (statement -> for_statement .)


state 15

    (59) type_info -> STRING .

    ID              reduce using rule 59 (type_info -> STRING .)
    LBRACKET        reduce using rule 59 (type_info -> STRING .)


state 16

    (24) for_statement -> FOR . ID IN ID
    (25) for_statement -> FOR . ID IN func_call

    ID              shift and go to state 49


state 17

    (4) statement -> assignment .

    RBRACKET        reduce using rule 4 (statement -> assignment .)
    CONST           reduce using rule 4 (statement -> assignment .)
    ID              reduce using rule 4 (statement -> assignment .)
    CALL            reduce using rule 4 (statement -> assignment .)
    RETURN          reduce using rule 4 (statement -> assignment .)
    FUNCTION        reduce using rule 4 (statement -> assignment .)
    IF              reduce using rule 4 (statement -> assignment .)
    WHILE           reduce using rule 4 (statement -> assignment .)
    FOR             reduce using rule 4 (statement -> assignment .)
    INT             reduce using rule 4 (statement -> assignment .)
    STRING          reduce using rule 4 (statement -> assignment .)
    REAL            reduce using rule 4 (statement -> assignment .)
    BOOLEAN         reduce using rule 4 (statement -> assignment .)
    CHAR            reduce using rule 4 (statement -> assignment .)
    $end            reduce using rule 4 (statement -> assignment .)


state 18

    (14) assignment -> ID . PLUSPLUS
    (15) assignment -> ID . MINUSMINUS
    (38) identifier -> ID .

    PLUSPLUS        shift and go to state 50
    MINUSMINUS      shift and go to state 51
    EQUALS          reduce using rule 38 (identifier -> ID .)


state 19

    (7) statement -> func_declaration .

    RBRACKET        reduce using rule 7 (statement -> func_declaration .)
    CONST           reduce using rule 7 (statement -> func_declaration .)
    ID              reduce using rule 7 (statement -> func_declaration .)
    CALL            reduce using rule 7 (statement -> func_declaration .)
    RETURN          reduce using rule 7 (statement -> func_declaration .)
    FUNCTION        reduce using rule 7 (statement -> func_declaration .)
    IF              reduce using rule 7 (statement -> func_declaration .)
    WHILE           reduce using rule 7 (statement -> func_declaration .)
    FOR             reduce using rule 7 (statement -> func_declaration .)
    INT             reduce using rule 7 (statement -> func_declaration .)
    STRING          reduce using rule 7 (statement -> func_declaration .)
    REAL            reduce using rule 7 (statement -> func_declaration .)
    BOOLEAN         reduce using rule 7 (statement -> func_declaration .)
    CHAR            reduce using rule 7 (statement -> func_declaration .)
    $end            reduce using rule 7 (statement -> func_declaration .)


state 20

    (5) statement -> func_call .

    RBRACKET        reduce using rule 5 (statement -> func_call .)
    CONST           reduce using rule 5 (statement -> func_call .)
    ID              reduce using rule 5 (statement -> func_call .)
    CALL            reduce using rule 5 (statement -> func_call .)
    RETURN          reduce using rule 5 (statement -> func_call .)
    FUNCTION        reduce using rule 5 (statement -> func_call .)
    IF              reduce using rule 5 (statement -> func_call .)
    WHILE           reduce using rule 5 (statement -> func_call .)
    FOR             reduce using rule 5 (statement -> func_call .)
    INT             reduce using rule 5 (statement -> func_call .)
    STRING          reduce using rule 5 (statement -> func_call .)
    REAL            reduce using rule 5 (statement -> func_call .)
    BOOLEAN         reduce using rule 5 (statement -> func_call .)
    CHAR            reduce using rule 5 (statement -> func_call .)
    $end            reduce using rule 5 (statement -> func_call .)


state 21

    (62) type_info -> CHAR .

    ID              reduce using rule 62 (type_info -> CHAR .)
    LBRACKET        reduce using rule 62 (type_info -> CHAR .)


state 22

    (58) type_info -> INT .

    ID              reduce using rule 58 (type_info -> INT .)
    LBRACKET        reduce using rule 58 (type_info -> INT .)


state 23

    (61) type_info -> BOOLEAN .

    ID              reduce using rule 61 (type_info -> BOOLEAN .)
    LBRACKET        reduce using rule 61 (type_info -> BOOLEAN .)


state 24

    (16) func_call -> CALL . identifier LPAREN arguments_list RPAREN
    (17) func_call -> CALL . identifier LPAREN RPAREN
    (38) identifier -> . ID

    ID              shift and go to state 28

    identifier                     shift and go to state 52

state 25

    (11) assignment -> identifier . EQUALS expression

    EQUALS          shift and go to state 53


state 26

    (13) assignment -> CONST type_info . identifier EQUALS value
    (38) identifier -> . ID

    ID              shift and go to state 28

    identifier                     shift and go to state 54

state 27

    (12) assignment -> type_info identifier . EQUALS expression

    EQUALS          shift and go to state 55


state 28

    (38) identifier -> ID .

    RPAREN          reduce using rule 38 (identifier -> ID .)
    COMMA           reduce using rule 38 (identifier -> ID .)
    AND             reduce using rule 38 (identifier -> ID .)
    OR              reduce using rule 38 (identifier -> ID .)
    GT              reduce using rule 38 (identifier -> ID .)
    LT              reduce using rule 38 (identifier -> ID .)
    GE              reduce using rule 38 (identifier -> ID .)
    LE              reduce using rule 38 (identifier -> ID .)
    ISEQUALS        reduce using rule 38 (identifier -> ID .)
    MODULO          reduce using rule 38 (identifier -> ID .)
    PLUS            reduce using rule 38 (identifier -> ID .)
    MINUS           reduce using rule 38 (identifier -> ID .)
    TIMES           reduce using rule 38 (identifier -> ID .)
    DIVIDE          reduce using rule 38 (identifier -> ID .)
    CONST           reduce using rule 38 (identifier -> ID .)
    ID              reduce using rule 38 (identifier -> ID .)
    CALL            reduce using rule 38 (identifier -> ID .)
    RETURN          reduce using rule 38 (identifier -> ID .)
    FUNCTION        reduce using rule 38 (identifier -> ID .)
    IF              reduce using rule 38 (identifier -> ID .)
    WHILE           reduce using rule 38 (identifier -> ID .)
    FOR             reduce using rule 38 (identifier -> ID .)
    INT             reduce using rule 38 (identifier -> ID .)
    STRING          reduce using rule 38 (identifier -> ID .)
    REAL            reduce using rule 38 (identifier -> ID .)
    BOOLEAN         reduce using rule 38 (identifier -> ID .)
    CHAR            reduce using rule 38 (identifier -> ID .)
    $end            reduce using rule 38 (identifier -> ID .)
    RBRACKET        reduce using rule 38 (identifier -> ID .)
    LBRACKET        reduce using rule 38 (identifier -> ID .)
    EQUALS          reduce using rule 38 (identifier -> ID .)
    LPAREN          reduce using rule 38 (identifier -> ID .)


state 29

    (39) value -> NUMBER .

    AND             reduce using rule 39 (value -> NUMBER .)
    OR              reduce using rule 39 (value -> NUMBER .)
    GT              reduce using rule 39 (value -> NUMBER .)
    LT              reduce using rule 39 (value -> NUMBER .)
    GE              reduce using rule 39 (value -> NUMBER .)
    LE              reduce using rule 39 (value -> NUMBER .)
    ISEQUALS        reduce using rule 39 (value -> NUMBER .)
    MODULO          reduce using rule 39 (value -> NUMBER .)
    PLUS            reduce using rule 39 (value -> NUMBER .)
    MINUS           reduce using rule 39 (value -> NUMBER .)
    TIMES           reduce using rule 39 (value -> NUMBER .)
    DIVIDE          reduce using rule 39 (value -> NUMBER .)
    CONST           reduce using rule 39 (value -> NUMBER .)
    ID              reduce using rule 39 (value -> NUMBER .)
    CALL            reduce using rule 39 (value -> NUMBER .)
    RETURN          reduce using rule 39 (value -> NUMBER .)
    FUNCTION        reduce using rule 39 (value -> NUMBER .)
    IF              reduce using rule 39 (value -> NUMBER .)
    WHILE           reduce using rule 39 (value -> NUMBER .)
    FOR             reduce using rule 39 (value -> NUMBER .)
    INT             reduce using rule 39 (value -> NUMBER .)
    STRING          reduce using rule 39 (value -> NUMBER .)
    REAL            reduce using rule 39 (value -> NUMBER .)
    BOOLEAN         reduce using rule 39 (value -> NUMBER .)
    CHAR            reduce using rule 39 (value -> NUMBER .)
    $end            reduce using rule 39 (value -> NUMBER .)
    RBRACKET        reduce using rule 39 (value -> NUMBER .)
    LBRACKET        reduce using rule 39 (value -> NUMBER .)
    RPAREN          reduce using rule 39 (value -> NUMBER .)
    COMMA           reduce using rule 39 (value -> NUMBER .)


state 30

    (35) simple_expression -> unary_op .

    AND             reduce using rule 35 (simple_expression -> unary_op .)
    OR              reduce using rule 35 (simple_expression -> unary_op .)
    GT              reduce using rule 35 (simple_expression -> unary_op .)
    LT              reduce using rule 35 (simple_expression -> unary_op .)
    GE              reduce using rule 35 (simple_expression -> unary_op .)
    LE              reduce using rule 35 (simple_expression -> unary_op .)
    ISEQUALS        reduce using rule 35 (simple_expression -> unary_op .)
    MODULO          reduce using rule 35 (simple_expression -> unary_op .)
    PLUS            reduce using rule 35 (simple_expression -> unary_op .)
    MINUS           reduce using rule 35 (simple_expression -> unary_op .)
    TIMES           reduce using rule 35 (simple_expression -> unary_op .)
    DIVIDE          reduce using rule 35 (simple_expression -> unary_op .)
    RPAREN          reduce using rule 35 (simple_expression -> unary_op .)
    COMMA           reduce using rule 35 (simple_expression -> unary_op .)
    CONST           reduce using rule 35 (simple_expression -> unary_op .)
    ID              reduce using rule 35 (simple_expression -> unary_op .)
    CALL            reduce using rule 35 (simple_expression -> unary_op .)
    RETURN          reduce using rule 35 (simple_expression -> unary_op .)
    FUNCTION        reduce using rule 35 (simple_expression -> unary_op .)
    IF              reduce using rule 35 (simple_expression -> unary_op .)
    WHILE           reduce using rule 35 (simple_expression -> unary_op .)
    FOR             reduce using rule 35 (simple_expression -> unary_op .)
    INT             reduce using rule 35 (simple_expression -> unary_op .)
    STRING          reduce using rule 35 (simple_expression -> unary_op .)
    REAL            reduce using rule 35 (simple_expression -> unary_op .)
    BOOLEAN         reduce using rule 35 (simple_expression -> unary_op .)
    CHAR            reduce using rule 35 (simple_expression -> unary_op .)
    $end            reduce using rule 35 (simple_expression -> unary_op .)
    RBRACKET        reduce using rule 35 (simple_expression -> unary_op .)
    LBRACKET        reduce using rule 35 (simple_expression -> unary_op .)


state 31

    (31) expression -> simple_expression .

    AND             reduce using rule 31 (expression -> simple_expression .)
    OR              reduce using rule 31 (expression -> simple_expression .)
    GT              reduce using rule 31 (expression -> simple_expression .)
    LT              reduce using rule 31 (expression -> simple_expression .)
    GE              reduce using rule 31 (expression -> simple_expression .)
    LE              reduce using rule 31 (expression -> simple_expression .)
    ISEQUALS        reduce using rule 31 (expression -> simple_expression .)
    MODULO          reduce using rule 31 (expression -> simple_expression .)
    PLUS            reduce using rule 31 (expression -> simple_expression .)
    MINUS           reduce using rule 31 (expression -> simple_expression .)
    TIMES           reduce using rule 31 (expression -> simple_expression .)
    DIVIDE          reduce using rule 31 (expression -> simple_expression .)
    CONST           reduce using rule 31 (expression -> simple_expression .)
    ID              reduce using rule 31 (expression -> simple_expression .)
    CALL            reduce using rule 31 (expression -> simple_expression .)
    RETURN          reduce using rule 31 (expression -> simple_expression .)
    FUNCTION        reduce using rule 31 (expression -> simple_expression .)
    IF              reduce using rule 31 (expression -> simple_expression .)
    WHILE           reduce using rule 31 (expression -> simple_expression .)
    FOR             reduce using rule 31 (expression -> simple_expression .)
    INT             reduce using rule 31 (expression -> simple_expression .)
    STRING          reduce using rule 31 (expression -> simple_expression .)
    REAL            reduce using rule 31 (expression -> simple_expression .)
    BOOLEAN         reduce using rule 31 (expression -> simple_expression .)
    CHAR            reduce using rule 31 (expression -> simple_expression .)
    $end            reduce using rule 31 (expression -> simple_expression .)
    RBRACKET        reduce using rule 31 (expression -> simple_expression .)
    LBRACKET        reduce using rule 31 (expression -> simple_expression .)
    RPAREN          reduce using rule 31 (expression -> simple_expression .)
    COMMA           reduce using rule 31 (expression -> simple_expression .)


state 32

    (42) value -> TRUE .

    AND             reduce using rule 42 (value -> TRUE .)
    OR              reduce using rule 42 (value -> TRUE .)
    GT              reduce using rule 42 (value -> TRUE .)
    LT              reduce using rule 42 (value -> TRUE .)
    GE              reduce using rule 42 (value -> TRUE .)
    LE              reduce using rule 42 (value -> TRUE .)
    ISEQUALS        reduce using rule 42 (value -> TRUE .)
    MODULO          reduce using rule 42 (value -> TRUE .)
    PLUS            reduce using rule 42 (value -> TRUE .)
    MINUS           reduce using rule 42 (value -> TRUE .)
    TIMES           reduce using rule 42 (value -> TRUE .)
    DIVIDE          reduce using rule 42 (value -> TRUE .)
    CONST           reduce using rule 42 (value -> TRUE .)
    ID              reduce using rule 42 (value -> TRUE .)
    CALL            reduce using rule 42 (value -> TRUE .)
    RETURN          reduce using rule 42 (value -> TRUE .)
    FUNCTION        reduce using rule 42 (value -> TRUE .)
    IF              reduce using rule 42 (value -> TRUE .)
    WHILE           reduce using rule 42 (value -> TRUE .)
    FOR             reduce using rule 42 (value -> TRUE .)
    INT             reduce using rule 42 (value -> TRUE .)
    STRING          reduce using rule 42 (value -> TRUE .)
    REAL            reduce using rule 42 (value -> TRUE .)
    BOOLEAN         reduce using rule 42 (value -> TRUE .)
    CHAR            reduce using rule 42 (value -> TRUE .)
    $end            reduce using rule 42 (value -> TRUE .)
    RBRACKET        reduce using rule 42 (value -> TRUE .)
    LBRACKET        reduce using rule 42 (value -> TRUE .)
    RPAREN          reduce using rule 42 (value -> TRUE .)
    COMMA           reduce using rule 42 (value -> TRUE .)


state 33

    (56) unary_op -> MINUS . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 56

state 34

    (40) value -> SLITERAL .

    AND             reduce using rule 40 (value -> SLITERAL .)
    OR              reduce using rule 40 (value -> SLITERAL .)
    GT              reduce using rule 40 (value -> SLITERAL .)
    LT              reduce using rule 40 (value -> SLITERAL .)
    GE              reduce using rule 40 (value -> SLITERAL .)
    LE              reduce using rule 40 (value -> SLITERAL .)
    ISEQUALS        reduce using rule 40 (value -> SLITERAL .)
    MODULO          reduce using rule 40 (value -> SLITERAL .)
    PLUS            reduce using rule 40 (value -> SLITERAL .)
    MINUS           reduce using rule 40 (value -> SLITERAL .)
    TIMES           reduce using rule 40 (value -> SLITERAL .)
    DIVIDE          reduce using rule 40 (value -> SLITERAL .)
    CONST           reduce using rule 40 (value -> SLITERAL .)
    ID              reduce using rule 40 (value -> SLITERAL .)
    CALL            reduce using rule 40 (value -> SLITERAL .)
    RETURN          reduce using rule 40 (value -> SLITERAL .)
    FUNCTION        reduce using rule 40 (value -> SLITERAL .)
    IF              reduce using rule 40 (value -> SLITERAL .)
    WHILE           reduce using rule 40 (value -> SLITERAL .)
    FOR             reduce using rule 40 (value -> SLITERAL .)
    INT             reduce using rule 40 (value -> SLITERAL .)
    STRING          reduce using rule 40 (value -> SLITERAL .)
    REAL            reduce using rule 40 (value -> SLITERAL .)
    BOOLEAN         reduce using rule 40 (value -> SLITERAL .)
    CHAR            reduce using rule 40 (value -> SLITERAL .)
    $end            reduce using rule 40 (value -> SLITERAL .)
    RBRACKET        reduce using rule 40 (value -> SLITERAL .)
    LBRACKET        reduce using rule 40 (value -> SLITERAL .)
    RPAREN          reduce using rule 40 (value -> SLITERAL .)
    COMMA           reduce using rule 40 (value -> SLITERAL .)


state 35

    (32) expression -> func_call .

    AND             reduce using rule 32 (expression -> func_call .)
    OR              reduce using rule 32 (expression -> func_call .)
    GT              reduce using rule 32 (expression -> func_call .)
    LT              reduce using rule 32 (expression -> func_call .)
    GE              reduce using rule 32 (expression -> func_call .)
    LE              reduce using rule 32 (expression -> func_call .)
    ISEQUALS        reduce using rule 32 (expression -> func_call .)
    MODULO          reduce using rule 32 (expression -> func_call .)
    PLUS            reduce using rule 32 (expression -> func_call .)
    MINUS           reduce using rule 32 (expression -> func_call .)
    TIMES           reduce using rule 32 (expression -> func_call .)
    DIVIDE          reduce using rule 32 (expression -> func_call .)
    CONST           reduce using rule 32 (expression -> func_call .)
    ID              reduce using rule 32 (expression -> func_call .)
    CALL            reduce using rule 32 (expression -> func_call .)
    RETURN          reduce using rule 32 (expression -> func_call .)
    FUNCTION        reduce using rule 32 (expression -> func_call .)
    IF              reduce using rule 32 (expression -> func_call .)
    WHILE           reduce using rule 32 (expression -> func_call .)
    FOR             reduce using rule 32 (expression -> func_call .)
    INT             reduce using rule 32 (expression -> func_call .)
    STRING          reduce using rule 32 (expression -> func_call .)
    REAL            reduce using rule 32 (expression -> func_call .)
    BOOLEAN         reduce using rule 32 (expression -> func_call .)
    CHAR            reduce using rule 32 (expression -> func_call .)
    $end            reduce using rule 32 (expression -> func_call .)
    RBRACKET        reduce using rule 32 (expression -> func_call .)
    LBRACKET        reduce using rule 32 (expression -> func_call .)
    RPAREN          reduce using rule 32 (expression -> func_call .)
    COMMA           reduce using rule 32 (expression -> func_call .)


state 36

    (23) while_statement -> WHILE binary_op . LBRACKET translation_unit RBRACKET
    (34) simple_expression -> binary_op .

    LBRACKET        shift and go to state 57
    AND             reduce using rule 34 (simple_expression -> binary_op .)
    OR              reduce using rule 34 (simple_expression -> binary_op .)
    GT              reduce using rule 34 (simple_expression -> binary_op .)
    LT              reduce using rule 34 (simple_expression -> binary_op .)
    GE              reduce using rule 34 (simple_expression -> binary_op .)
    LE              reduce using rule 34 (simple_expression -> binary_op .)
    ISEQUALS        reduce using rule 34 (simple_expression -> binary_op .)
    MODULO          reduce using rule 34 (simple_expression -> binary_op .)
    PLUS            reduce using rule 34 (simple_expression -> binary_op .)
    MINUS           reduce using rule 34 (simple_expression -> binary_op .)
    TIMES           reduce using rule 34 (simple_expression -> binary_op .)
    DIVIDE          reduce using rule 34 (simple_expression -> binary_op .)


state 37

    (33) expression -> atom .

    AND             reduce using rule 33 (expression -> atom .)
    OR              reduce using rule 33 (expression -> atom .)
    GT              reduce using rule 33 (expression -> atom .)
    LT              reduce using rule 33 (expression -> atom .)
    GE              reduce using rule 33 (expression -> atom .)
    LE              reduce using rule 33 (expression -> atom .)
    ISEQUALS        reduce using rule 33 (expression -> atom .)
    MODULO          reduce using rule 33 (expression -> atom .)
    PLUS            reduce using rule 33 (expression -> atom .)
    MINUS           reduce using rule 33 (expression -> atom .)
    TIMES           reduce using rule 33 (expression -> atom .)
    DIVIDE          reduce using rule 33 (expression -> atom .)
    CONST           reduce using rule 33 (expression -> atom .)
    ID              reduce using rule 33 (expression -> atom .)
    CALL            reduce using rule 33 (expression -> atom .)
    RETURN          reduce using rule 33 (expression -> atom .)
    FUNCTION        reduce using rule 33 (expression -> atom .)
    IF              reduce using rule 33 (expression -> atom .)
    WHILE           reduce using rule 33 (expression -> atom .)
    FOR             reduce using rule 33 (expression -> atom .)
    INT             reduce using rule 33 (expression -> atom .)
    STRING          reduce using rule 33 (expression -> atom .)
    REAL            reduce using rule 33 (expression -> atom .)
    BOOLEAN         reduce using rule 33 (expression -> atom .)
    CHAR            reduce using rule 33 (expression -> atom .)
    $end            reduce using rule 33 (expression -> atom .)
    RBRACKET        reduce using rule 33 (expression -> atom .)
    LBRACKET        reduce using rule 33 (expression -> atom .)
    RPAREN          reduce using rule 33 (expression -> atom .)
    COMMA           reduce using rule 33 (expression -> atom .)


state 38

    (43) value -> FALSE .

    AND             reduce using rule 43 (value -> FALSE .)
    OR              reduce using rule 43 (value -> FALSE .)
    GT              reduce using rule 43 (value -> FALSE .)
    LT              reduce using rule 43 (value -> FALSE .)
    GE              reduce using rule 43 (value -> FALSE .)
    LE              reduce using rule 43 (value -> FALSE .)
    ISEQUALS        reduce using rule 43 (value -> FALSE .)
    MODULO          reduce using rule 43 (value -> FALSE .)
    PLUS            reduce using rule 43 (value -> FALSE .)
    MINUS           reduce using rule 43 (value -> FALSE .)
    TIMES           reduce using rule 43 (value -> FALSE .)
    DIVIDE          reduce using rule 43 (value -> FALSE .)
    CONST           reduce using rule 43 (value -> FALSE .)
    ID              reduce using rule 43 (value -> FALSE .)
    CALL            reduce using rule 43 (value -> FALSE .)
    RETURN          reduce using rule 43 (value -> FALSE .)
    FUNCTION        reduce using rule 43 (value -> FALSE .)
    IF              reduce using rule 43 (value -> FALSE .)
    WHILE           reduce using rule 43 (value -> FALSE .)
    FOR             reduce using rule 43 (value -> FALSE .)
    INT             reduce using rule 43 (value -> FALSE .)
    STRING          reduce using rule 43 (value -> FALSE .)
    REAL            reduce using rule 43 (value -> FALSE .)
    BOOLEAN         reduce using rule 43 (value -> FALSE .)
    CHAR            reduce using rule 43 (value -> FALSE .)
    $end            reduce using rule 43 (value -> FALSE .)
    RBRACKET        reduce using rule 43 (value -> FALSE .)
    LBRACKET        reduce using rule 43 (value -> FALSE .)
    RPAREN          reduce using rule 43 (value -> FALSE .)
    COMMA           reduce using rule 43 (value -> FALSE .)


state 39

    (41) value -> FLOAT .

    AND             reduce using rule 41 (value -> FLOAT .)
    OR              reduce using rule 41 (value -> FLOAT .)
    GT              reduce using rule 41 (value -> FLOAT .)
    LT              reduce using rule 41 (value -> FLOAT .)
    GE              reduce using rule 41 (value -> FLOAT .)
    LE              reduce using rule 41 (value -> FLOAT .)
    ISEQUALS        reduce using rule 41 (value -> FLOAT .)
    MODULO          reduce using rule 41 (value -> FLOAT .)
    PLUS            reduce using rule 41 (value -> FLOAT .)
    MINUS           reduce using rule 41 (value -> FLOAT .)
    TIMES           reduce using rule 41 (value -> FLOAT .)
    DIVIDE          reduce using rule 41 (value -> FLOAT .)
    CONST           reduce using rule 41 (value -> FLOAT .)
    ID              reduce using rule 41 (value -> FLOAT .)
    CALL            reduce using rule 41 (value -> FLOAT .)
    RETURN          reduce using rule 41 (value -> FLOAT .)
    FUNCTION        reduce using rule 41 (value -> FLOAT .)
    IF              reduce using rule 41 (value -> FLOAT .)
    WHILE           reduce using rule 41 (value -> FLOAT .)
    FOR             reduce using rule 41 (value -> FLOAT .)
    INT             reduce using rule 41 (value -> FLOAT .)
    STRING          reduce using rule 41 (value -> FLOAT .)
    REAL            reduce using rule 41 (value -> FLOAT .)
    BOOLEAN         reduce using rule 41 (value -> FLOAT .)
    CHAR            reduce using rule 41 (value -> FLOAT .)
    $end            reduce using rule 41 (value -> FLOAT .)
    RBRACKET        reduce using rule 41 (value -> FLOAT .)
    LBRACKET        reduce using rule 41 (value -> FLOAT .)
    RPAREN          reduce using rule 41 (value -> FLOAT .)
    COMMA           reduce using rule 41 (value -> FLOAT .)


state 40

    (37) atom -> value .

    AND             reduce using rule 37 (atom -> value .)
    OR              reduce using rule 37 (atom -> value .)
    GT              reduce using rule 37 (atom -> value .)
    LT              reduce using rule 37 (atom -> value .)
    GE              reduce using rule 37 (atom -> value .)
    LE              reduce using rule 37 (atom -> value .)
    ISEQUALS        reduce using rule 37 (atom -> value .)
    MODULO          reduce using rule 37 (atom -> value .)
    PLUS            reduce using rule 37 (atom -> value .)
    MINUS           reduce using rule 37 (atom -> value .)
    TIMES           reduce using rule 37 (atom -> value .)
    DIVIDE          reduce using rule 37 (atom -> value .)
    CONST           reduce using rule 37 (atom -> value .)
    ID              reduce using rule 37 (atom -> value .)
    CALL            reduce using rule 37 (atom -> value .)
    RETURN          reduce using rule 37 (atom -> value .)
    FUNCTION        reduce using rule 37 (atom -> value .)
    IF              reduce using rule 37 (atom -> value .)
    WHILE           reduce using rule 37 (atom -> value .)
    FOR             reduce using rule 37 (atom -> value .)
    INT             reduce using rule 37 (atom -> value .)
    STRING          reduce using rule 37 (atom -> value .)
    REAL            reduce using rule 37 (atom -> value .)
    BOOLEAN         reduce using rule 37 (atom -> value .)
    CHAR            reduce using rule 37 (atom -> value .)
    $end            reduce using rule 37 (atom -> value .)
    RBRACKET        reduce using rule 37 (atom -> value .)
    LBRACKET        reduce using rule 37 (atom -> value .)
    RPAREN          reduce using rule 37 (atom -> value .)
    COMMA           reduce using rule 37 (atom -> value .)


state 41

    (57) unary_op -> NOT . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 58

state 42

    (36) atom -> identifier .

    AND             reduce using rule 36 (atom -> identifier .)
    OR              reduce using rule 36 (atom -> identifier .)
    GT              reduce using rule 36 (atom -> identifier .)
    LT              reduce using rule 36 (atom -> identifier .)
    GE              reduce using rule 36 (atom -> identifier .)
    LE              reduce using rule 36 (atom -> identifier .)
    ISEQUALS        reduce using rule 36 (atom -> identifier .)
    MODULO          reduce using rule 36 (atom -> identifier .)
    PLUS            reduce using rule 36 (atom -> identifier .)
    MINUS           reduce using rule 36 (atom -> identifier .)
    TIMES           reduce using rule 36 (atom -> identifier .)
    DIVIDE          reduce using rule 36 (atom -> identifier .)
    CONST           reduce using rule 36 (atom -> identifier .)
    ID              reduce using rule 36 (atom -> identifier .)
    CALL            reduce using rule 36 (atom -> identifier .)
    RETURN          reduce using rule 36 (atom -> identifier .)
    FUNCTION        reduce using rule 36 (atom -> identifier .)
    IF              reduce using rule 36 (atom -> identifier .)
    WHILE           reduce using rule 36 (atom -> identifier .)
    FOR             reduce using rule 36 (atom -> identifier .)
    INT             reduce using rule 36 (atom -> identifier .)
    STRING          reduce using rule 36 (atom -> identifier .)
    REAL            reduce using rule 36 (atom -> identifier .)
    BOOLEAN         reduce using rule 36 (atom -> identifier .)
    CHAR            reduce using rule 36 (atom -> identifier .)
    $end            reduce using rule 36 (atom -> identifier .)
    RBRACKET        reduce using rule 36 (atom -> identifier .)
    LBRACKET        reduce using rule 36 (atom -> identifier .)
    RPAREN          reduce using rule 36 (atom -> identifier .)
    COMMA           reduce using rule 36 (atom -> identifier .)


state 43

    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62


state 44

    (21) if_statement -> IF binary_op . LBRACKET translation_unit RBRACKET
    (34) simple_expression -> binary_op .

    LBRACKET        shift and go to state 71
    AND             reduce using rule 34 (simple_expression -> binary_op .)
    OR              reduce using rule 34 (simple_expression -> binary_op .)
    GT              reduce using rule 34 (simple_expression -> binary_op .)
    LT              reduce using rule 34 (simple_expression -> binary_op .)
    GE              reduce using rule 34 (simple_expression -> binary_op .)
    LE              reduce using rule 34 (simple_expression -> binary_op .)
    ISEQUALS        reduce using rule 34 (simple_expression -> binary_op .)
    MODULO          reduce using rule 34 (simple_expression -> binary_op .)
    PLUS            reduce using rule 34 (simple_expression -> binary_op .)
    MINUS           reduce using rule 34 (simple_expression -> binary_op .)
    TIMES           reduce using rule 34 (simple_expression -> binary_op .)
    DIVIDE          reduce using rule 34 (simple_expression -> binary_op .)


state 45

    (34) simple_expression -> binary_op .

    AND             reduce using rule 34 (simple_expression -> binary_op .)
    OR              reduce using rule 34 (simple_expression -> binary_op .)
    GT              reduce using rule 34 (simple_expression -> binary_op .)
    LT              reduce using rule 34 (simple_expression -> binary_op .)
    GE              reduce using rule 34 (simple_expression -> binary_op .)
    LE              reduce using rule 34 (simple_expression -> binary_op .)
    ISEQUALS        reduce using rule 34 (simple_expression -> binary_op .)
    MODULO          reduce using rule 34 (simple_expression -> binary_op .)
    PLUS            reduce using rule 34 (simple_expression -> binary_op .)
    MINUS           reduce using rule 34 (simple_expression -> binary_op .)
    TIMES           reduce using rule 34 (simple_expression -> binary_op .)
    DIVIDE          reduce using rule 34 (simple_expression -> binary_op .)
    RPAREN          reduce using rule 34 (simple_expression -> binary_op .)
    COMMA           reduce using rule 34 (simple_expression -> binary_op .)
    CONST           reduce using rule 34 (simple_expression -> binary_op .)
    ID              reduce using rule 34 (simple_expression -> binary_op .)
    CALL            reduce using rule 34 (simple_expression -> binary_op .)
    RETURN          reduce using rule 34 (simple_expression -> binary_op .)
    FUNCTION        reduce using rule 34 (simple_expression -> binary_op .)
    IF              reduce using rule 34 (simple_expression -> binary_op .)
    WHILE           reduce using rule 34 (simple_expression -> binary_op .)
    FOR             reduce using rule 34 (simple_expression -> binary_op .)
    INT             reduce using rule 34 (simple_expression -> binary_op .)
    STRING          reduce using rule 34 (simple_expression -> binary_op .)
    REAL            reduce using rule 34 (simple_expression -> binary_op .)
    BOOLEAN         reduce using rule 34 (simple_expression -> binary_op .)
    CHAR            reduce using rule 34 (simple_expression -> binary_op .)
    $end            reduce using rule 34 (simple_expression -> binary_op .)
    RBRACKET        reduce using rule 34 (simple_expression -> binary_op .)
    LBRACKET        reduce using rule 34 (simple_expression -> binary_op .)


state 46

    (20) return_statement -> RETURN expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    RBRACKET        reduce using rule 20 (return_statement -> RETURN expression .)
    CONST           reduce using rule 20 (return_statement -> RETURN expression .)
    ID              reduce using rule 20 (return_statement -> RETURN expression .)
    CALL            reduce using rule 20 (return_statement -> RETURN expression .)
    RETURN          reduce using rule 20 (return_statement -> RETURN expression .)
    FUNCTION        reduce using rule 20 (return_statement -> RETURN expression .)
    IF              reduce using rule 20 (return_statement -> RETURN expression .)
    WHILE           reduce using rule 20 (return_statement -> RETURN expression .)
    FOR             reduce using rule 20 (return_statement -> RETURN expression .)
    INT             reduce using rule 20 (return_statement -> RETURN expression .)
    STRING          reduce using rule 20 (return_statement -> RETURN expression .)
    REAL            reduce using rule 20 (return_statement -> RETURN expression .)
    BOOLEAN         reduce using rule 20 (return_statement -> RETURN expression .)
    CHAR            reduce using rule 20 (return_statement -> RETURN expression .)
    $end            reduce using rule 20 (return_statement -> RETURN expression .)
    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62


state 47

    (3) translation_unit -> translation_unit statement .

    RBRACKET        reduce using rule 3 (translation_unit -> translation_unit statement .)
    CONST           reduce using rule 3 (translation_unit -> translation_unit statement .)
    ID              reduce using rule 3 (translation_unit -> translation_unit statement .)
    CALL            reduce using rule 3 (translation_unit -> translation_unit statement .)
    RETURN          reduce using rule 3 (translation_unit -> translation_unit statement .)
    FUNCTION        reduce using rule 3 (translation_unit -> translation_unit statement .)
    IF              reduce using rule 3 (translation_unit -> translation_unit statement .)
    WHILE           reduce using rule 3 (translation_unit -> translation_unit statement .)
    FOR             reduce using rule 3 (translation_unit -> translation_unit statement .)
    INT             reduce using rule 3 (translation_unit -> translation_unit statement .)
    STRING          reduce using rule 3 (translation_unit -> translation_unit statement .)
    REAL            reduce using rule 3 (translation_unit -> translation_unit statement .)
    BOOLEAN         reduce using rule 3 (translation_unit -> translation_unit statement .)
    CHAR            reduce using rule 3 (translation_unit -> translation_unit statement .)
    $end            reduce using rule 3 (translation_unit -> translation_unit statement .)


state 48

    (18) func_declaration -> FUNCTION identifier . LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> FUNCTION identifier . LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET

    LPAREN          shift and go to state 72


state 49

    (24) for_statement -> FOR ID . IN ID
    (25) for_statement -> FOR ID . IN func_call

    IN              shift and go to state 73


state 50

    (14) assignment -> ID PLUSPLUS .

    RBRACKET        reduce using rule 14 (assignment -> ID PLUSPLUS .)
    CONST           reduce using rule 14 (assignment -> ID PLUSPLUS .)
    ID              reduce using rule 14 (assignment -> ID PLUSPLUS .)
    CALL            reduce using rule 14 (assignment -> ID PLUSPLUS .)
    RETURN          reduce using rule 14 (assignment -> ID PLUSPLUS .)
    FUNCTION        reduce using rule 14 (assignment -> ID PLUSPLUS .)
    IF              reduce using rule 14 (assignment -> ID PLUSPLUS .)
    WHILE           reduce using rule 14 (assignment -> ID PLUSPLUS .)
    FOR             reduce using rule 14 (assignment -> ID PLUSPLUS .)
    INT             reduce using rule 14 (assignment -> ID PLUSPLUS .)
    STRING          reduce using rule 14 (assignment -> ID PLUSPLUS .)
    REAL            reduce using rule 14 (assignment -> ID PLUSPLUS .)
    BOOLEAN         reduce using rule 14 (assignment -> ID PLUSPLUS .)
    CHAR            reduce using rule 14 (assignment -> ID PLUSPLUS .)
    $end            reduce using rule 14 (assignment -> ID PLUSPLUS .)


state 51

    (15) assignment -> ID MINUSMINUS .

    RBRACKET        reduce using rule 15 (assignment -> ID MINUSMINUS .)
    CONST           reduce using rule 15 (assignment -> ID MINUSMINUS .)
    ID              reduce using rule 15 (assignment -> ID MINUSMINUS .)
    CALL            reduce using rule 15 (assignment -> ID MINUSMINUS .)
    RETURN          reduce using rule 15 (assignment -> ID MINUSMINUS .)
    FUNCTION        reduce using rule 15 (assignment -> ID MINUSMINUS .)
    IF              reduce using rule 15 (assignment -> ID MINUSMINUS .)
    WHILE           reduce using rule 15 (assignment -> ID MINUSMINUS .)
    FOR             reduce using rule 15 (assignment -> ID MINUSMINUS .)
    INT             reduce using rule 15 (assignment -> ID MINUSMINUS .)
    STRING          reduce using rule 15 (assignment -> ID MINUSMINUS .)
    REAL            reduce using rule 15 (assignment -> ID MINUSMINUS .)
    BOOLEAN         reduce using rule 15 (assignment -> ID MINUSMINUS .)
    CHAR            reduce using rule 15 (assignment -> ID MINUSMINUS .)
    $end            reduce using rule 15 (assignment -> ID MINUSMINUS .)


state 52

    (16) func_call -> CALL identifier . LPAREN arguments_list RPAREN
    (17) func_call -> CALL identifier . LPAREN RPAREN

    LPAREN          shift and go to state 74


state 53

    (11) assignment -> identifier EQUALS . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 75

state 54

    (13) assignment -> CONST type_info identifier . EQUALS value

    EQUALS          shift and go to state 76


state 55

    (12) assignment -> type_info identifier EQUALS . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    value                          shift and go to state 40
    binary_op                      shift and go to state 45
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 77

state 56

    (56) unary_op -> MINUS expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 56 (unary_op -> MINUS expression .)
    OR              reduce using rule 56 (unary_op -> MINUS expression .)
    GT              reduce using rule 56 (unary_op -> MINUS expression .)
    LT              reduce using rule 56 (unary_op -> MINUS expression .)
    GE              reduce using rule 56 (unary_op -> MINUS expression .)
    LE              reduce using rule 56 (unary_op -> MINUS expression .)
    ISEQUALS        reduce using rule 56 (unary_op -> MINUS expression .)
    MODULO          reduce using rule 56 (unary_op -> MINUS expression .)
    PLUS            reduce using rule 56 (unary_op -> MINUS expression .)
    MINUS           reduce using rule 56 (unary_op -> MINUS expression .)
    TIMES           reduce using rule 56 (unary_op -> MINUS expression .)
    DIVIDE          reduce using rule 56 (unary_op -> MINUS expression .)
    CONST           reduce using rule 56 (unary_op -> MINUS expression .)
    ID              reduce using rule 56 (unary_op -> MINUS expression .)
    CALL            reduce using rule 56 (unary_op -> MINUS expression .)
    RETURN          reduce using rule 56 (unary_op -> MINUS expression .)
    FUNCTION        reduce using rule 56 (unary_op -> MINUS expression .)
    IF              reduce using rule 56 (unary_op -> MINUS expression .)
    WHILE           reduce using rule 56 (unary_op -> MINUS expression .)
    FOR             reduce using rule 56 (unary_op -> MINUS expression .)
    INT             reduce using rule 56 (unary_op -> MINUS expression .)
    STRING          reduce using rule 56 (unary_op -> MINUS expression .)
    REAL            reduce using rule 56 (unary_op -> MINUS expression .)
    BOOLEAN         reduce using rule 56 (unary_op -> MINUS expression .)
    CHAR            reduce using rule 56 (unary_op -> MINUS expression .)
    $end            reduce using rule 56 (unary_op -> MINUS expression .)
    RBRACKET        reduce using rule 56 (unary_op -> MINUS expression .)
    LBRACKET        reduce using rule 56 (unary_op -> MINUS expression .)
    RPAREN          reduce using rule 56 (unary_op -> MINUS expression .)
    COMMA           reduce using rule 56 (unary_op -> MINUS expression .)

  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]
  ! MODULO          [ shift and go to state 61 ]
  ! PLUS            [ shift and go to state 68 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 62 ]


state 57

    (23) while_statement -> WHILE binary_op LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    identifier                     shift and go to state 25
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 10
    if_statement                   shift and go to state 11
    translation_unit               shift and go to state 78
    func_declaration               shift and go to state 19

state 58

    (57) unary_op -> NOT expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for ISEQUALS resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    CONST           reduce using rule 57 (unary_op -> NOT expression .)
    ID              reduce using rule 57 (unary_op -> NOT expression .)
    CALL            reduce using rule 57 (unary_op -> NOT expression .)
    RETURN          reduce using rule 57 (unary_op -> NOT expression .)
    FUNCTION        reduce using rule 57 (unary_op -> NOT expression .)
    IF              reduce using rule 57 (unary_op -> NOT expression .)
    WHILE           reduce using rule 57 (unary_op -> NOT expression .)
    FOR             reduce using rule 57 (unary_op -> NOT expression .)
    INT             reduce using rule 57 (unary_op -> NOT expression .)
    STRING          reduce using rule 57 (unary_op -> NOT expression .)
    REAL            reduce using rule 57 (unary_op -> NOT expression .)
    BOOLEAN         reduce using rule 57 (unary_op -> NOT expression .)
    CHAR            reduce using rule 57 (unary_op -> NOT expression .)
    $end            reduce using rule 57 (unary_op -> NOT expression .)
    RBRACKET        reduce using rule 57 (unary_op -> NOT expression .)
    LBRACKET        reduce using rule 57 (unary_op -> NOT expression .)
    RPAREN          reduce using rule 57 (unary_op -> NOT expression .)
    COMMA           reduce using rule 57 (unary_op -> NOT expression .)
    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! AND             [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! OR              [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! GT              [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! LT              [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! GE              [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! LE              [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! ISEQUALS        [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! MODULO          [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! PLUS            [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! MINUS           [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! TIMES           [ reduce using rule 57 (unary_op -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 57 (unary_op -> NOT expression .) ]


state 59

    (44) binary_op -> expression AND . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 79

state 60

    (46) binary_op -> expression GT . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 80

state 61

    (51) binary_op -> expression MODULO . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 81

state 62

    (55) binary_op -> expression DIVIDE . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 82

state 63

    (50) binary_op -> expression ISEQUALS . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 83

state 64

    (47) binary_op -> expression LT . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 84

state 65

    (53) binary_op -> expression MINUS . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 85

state 66

    (48) binary_op -> expression GE . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 86

state 67

    (49) binary_op -> expression LE . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 87

state 68

    (52) binary_op -> expression PLUS . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 88

state 69

    (54) binary_op -> expression TIMES . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 89

state 70

    (45) binary_op -> expression OR . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 90

state 71

    (21) if_statement -> IF binary_op LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    identifier                     shift and go to state 25
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 10
    if_statement                   shift and go to state 11
    translation_unit               shift and go to state 91
    func_declaration               shift and go to state 19

state 72

    (18) func_declaration -> FUNCTION identifier LPAREN . params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> FUNCTION identifier LPAREN . RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (26) params_list -> . parameter_declaration
    (27) params_list -> . params_list COMMA parameter_declaration
    (28) parameter_declaration -> . type_info identifier
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    RPAREN          shift and go to state 92
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    parameter_declaration          shift and go to state 93
    params_list                    shift and go to state 95
    type_info                      shift and go to state 94

state 73

    (24) for_statement -> FOR ID IN . ID
    (25) for_statement -> FOR ID IN . func_call
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN

    ID              shift and go to state 97
    CALL            shift and go to state 24

    func_call                      shift and go to state 96

state 74

    (16) func_call -> CALL identifier LPAREN . arguments_list RPAREN
    (17) func_call -> CALL identifier LPAREN . RPAREN
    (29) arguments_list -> . expression
    (30) arguments_list -> . arguments_list COMMA expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    RPAREN          shift and go to state 99
    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    arguments_list                 shift and go to state 98
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 100

state 75

    (11) assignment -> identifier EQUALS expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    RBRACKET        reduce using rule 11 (assignment -> identifier EQUALS expression .)
    CONST           reduce using rule 11 (assignment -> identifier EQUALS expression .)
    ID              reduce using rule 11 (assignment -> identifier EQUALS expression .)
    CALL            reduce using rule 11 (assignment -> identifier EQUALS expression .)
    RETURN          reduce using rule 11 (assignment -> identifier EQUALS expression .)
    FUNCTION        reduce using rule 11 (assignment -> identifier EQUALS expression .)
    IF              reduce using rule 11 (assignment -> identifier EQUALS expression .)
    WHILE           reduce using rule 11 (assignment -> identifier EQUALS expression .)
    FOR             reduce using rule 11 (assignment -> identifier EQUALS expression .)
    INT             reduce using rule 11 (assignment -> identifier EQUALS expression .)
    STRING          reduce using rule 11 (assignment -> identifier EQUALS expression .)
    REAL            reduce using rule 11 (assignment -> identifier EQUALS expression .)
    BOOLEAN         reduce using rule 11 (assignment -> identifier EQUALS expression .)
    CHAR            reduce using rule 11 (assignment -> identifier EQUALS expression .)
    $end            reduce using rule 11 (assignment -> identifier EQUALS expression .)
    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62


state 76

    (13) assignment -> CONST type_info identifier EQUALS . value
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    value                          shift and go to state 101

state 77

    (12) assignment -> type_info identifier EQUALS expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    RBRACKET        reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    CONST           reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    ID              reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    CALL            reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    RETURN          reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    FUNCTION        reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    IF              reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    WHILE           reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    FOR             reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    INT             reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    STRING          reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    REAL            reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    BOOLEAN         reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    CHAR            reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    $end            reduce using rule 12 (assignment -> type_info identifier EQUALS expression .)
    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62


state 78

    (23) while_statement -> WHILE binary_op LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    RBRACKET        shift and go to state 102
    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    identifier                     shift and go to state 25
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 47
    if_statement                   shift and go to state 11
    func_declaration               shift and go to state 19

state 79

    (44) binary_op -> expression AND expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 44 (binary_op -> expression AND expression .)
    OR              reduce using rule 44 (binary_op -> expression AND expression .)
    ISEQUALS        reduce using rule 44 (binary_op -> expression AND expression .)
    CONST           reduce using rule 44 (binary_op -> expression AND expression .)
    ID              reduce using rule 44 (binary_op -> expression AND expression .)
    CALL            reduce using rule 44 (binary_op -> expression AND expression .)
    RETURN          reduce using rule 44 (binary_op -> expression AND expression .)
    FUNCTION        reduce using rule 44 (binary_op -> expression AND expression .)
    IF              reduce using rule 44 (binary_op -> expression AND expression .)
    WHILE           reduce using rule 44 (binary_op -> expression AND expression .)
    FOR             reduce using rule 44 (binary_op -> expression AND expression .)
    INT             reduce using rule 44 (binary_op -> expression AND expression .)
    STRING          reduce using rule 44 (binary_op -> expression AND expression .)
    REAL            reduce using rule 44 (binary_op -> expression AND expression .)
    BOOLEAN         reduce using rule 44 (binary_op -> expression AND expression .)
    CHAR            reduce using rule 44 (binary_op -> expression AND expression .)
    $end            reduce using rule 44 (binary_op -> expression AND expression .)
    RBRACKET        reduce using rule 44 (binary_op -> expression AND expression .)
    LBRACKET        reduce using rule 44 (binary_op -> expression AND expression .)
    RPAREN          reduce using rule 44 (binary_op -> expression AND expression .)
    COMMA           reduce using rule 44 (binary_op -> expression AND expression .)
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! GT              [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! LT              [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! GE              [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! LE              [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! MODULO          [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! PLUS            [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 44 (binary_op -> expression AND expression .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! ISEQUALS        [ shift and go to state 63 ]


state 80

    (46) binary_op -> expression GT expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 46 (binary_op -> expression GT expression .)
    OR              reduce using rule 46 (binary_op -> expression GT expression .)
    GT              reduce using rule 46 (binary_op -> expression GT expression .)
    LT              reduce using rule 46 (binary_op -> expression GT expression .)
    GE              reduce using rule 46 (binary_op -> expression GT expression .)
    LE              reduce using rule 46 (binary_op -> expression GT expression .)
    ISEQUALS        reduce using rule 46 (binary_op -> expression GT expression .)
    CONST           reduce using rule 46 (binary_op -> expression GT expression .)
    ID              reduce using rule 46 (binary_op -> expression GT expression .)
    CALL            reduce using rule 46 (binary_op -> expression GT expression .)
    RETURN          reduce using rule 46 (binary_op -> expression GT expression .)
    FUNCTION        reduce using rule 46 (binary_op -> expression GT expression .)
    IF              reduce using rule 46 (binary_op -> expression GT expression .)
    WHILE           reduce using rule 46 (binary_op -> expression GT expression .)
    FOR             reduce using rule 46 (binary_op -> expression GT expression .)
    INT             reduce using rule 46 (binary_op -> expression GT expression .)
    STRING          reduce using rule 46 (binary_op -> expression GT expression .)
    REAL            reduce using rule 46 (binary_op -> expression GT expression .)
    BOOLEAN         reduce using rule 46 (binary_op -> expression GT expression .)
    CHAR            reduce using rule 46 (binary_op -> expression GT expression .)
    $end            reduce using rule 46 (binary_op -> expression GT expression .)
    RBRACKET        reduce using rule 46 (binary_op -> expression GT expression .)
    LBRACKET        reduce using rule 46 (binary_op -> expression GT expression .)
    RPAREN          reduce using rule 46 (binary_op -> expression GT expression .)
    COMMA           reduce using rule 46 (binary_op -> expression GT expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! MODULO          [ reduce using rule 46 (binary_op -> expression GT expression .) ]
  ! PLUS            [ reduce using rule 46 (binary_op -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 46 (binary_op -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 46 (binary_op -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 46 (binary_op -> expression GT expression .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]


state 81

    (51) binary_op -> expression MODULO expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 51 (binary_op -> expression MODULO expression .)
    OR              reduce using rule 51 (binary_op -> expression MODULO expression .)
    GT              reduce using rule 51 (binary_op -> expression MODULO expression .)
    LT              reduce using rule 51 (binary_op -> expression MODULO expression .)
    GE              reduce using rule 51 (binary_op -> expression MODULO expression .)
    LE              reduce using rule 51 (binary_op -> expression MODULO expression .)
    ISEQUALS        reduce using rule 51 (binary_op -> expression MODULO expression .)
    MODULO          reduce using rule 51 (binary_op -> expression MODULO expression .)
    PLUS            reduce using rule 51 (binary_op -> expression MODULO expression .)
    MINUS           reduce using rule 51 (binary_op -> expression MODULO expression .)
    TIMES           reduce using rule 51 (binary_op -> expression MODULO expression .)
    DIVIDE          reduce using rule 51 (binary_op -> expression MODULO expression .)
    CONST           reduce using rule 51 (binary_op -> expression MODULO expression .)
    ID              reduce using rule 51 (binary_op -> expression MODULO expression .)
    CALL            reduce using rule 51 (binary_op -> expression MODULO expression .)
    RETURN          reduce using rule 51 (binary_op -> expression MODULO expression .)
    FUNCTION        reduce using rule 51 (binary_op -> expression MODULO expression .)
    IF              reduce using rule 51 (binary_op -> expression MODULO expression .)
    WHILE           reduce using rule 51 (binary_op -> expression MODULO expression .)
    FOR             reduce using rule 51 (binary_op -> expression MODULO expression .)
    INT             reduce using rule 51 (binary_op -> expression MODULO expression .)
    STRING          reduce using rule 51 (binary_op -> expression MODULO expression .)
    REAL            reduce using rule 51 (binary_op -> expression MODULO expression .)
    BOOLEAN         reduce using rule 51 (binary_op -> expression MODULO expression .)
    CHAR            reduce using rule 51 (binary_op -> expression MODULO expression .)
    $end            reduce using rule 51 (binary_op -> expression MODULO expression .)
    RBRACKET        reduce using rule 51 (binary_op -> expression MODULO expression .)
    LBRACKET        reduce using rule 51 (binary_op -> expression MODULO expression .)
    RPAREN          reduce using rule 51 (binary_op -> expression MODULO expression .)
    COMMA           reduce using rule 51 (binary_op -> expression MODULO expression .)

  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]
  ! MODULO          [ shift and go to state 61 ]
  ! PLUS            [ shift and go to state 68 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 62 ]


state 82

    (55) binary_op -> expression DIVIDE expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    OR              reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    GT              reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    LT              reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    GE              reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    LE              reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    ISEQUALS        reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    MODULO          reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    PLUS            reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    MINUS           reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    TIMES           reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    CONST           reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    ID              reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    CALL            reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    RETURN          reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    FUNCTION        reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    IF              reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    WHILE           reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    FOR             reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    INT             reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    STRING          reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    REAL            reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    BOOLEAN         reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    CHAR            reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    $end            reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    RPAREN          reduce using rule 55 (binary_op -> expression DIVIDE expression .)
    COMMA           reduce using rule 55 (binary_op -> expression DIVIDE expression .)

  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]
  ! MODULO          [ shift and go to state 61 ]
  ! PLUS            [ shift and go to state 68 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 62 ]


state 83

    (50) binary_op -> expression ISEQUALS expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for ISEQUALS resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    CONST           reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    ID              reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    CALL            reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    RETURN          reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    FUNCTION        reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    IF              reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    WHILE           reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    FOR             reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    INT             reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    STRING          reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    REAL            reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    BOOLEAN         reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    CHAR            reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    $end            reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    RBRACKET        reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    LBRACKET        reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    RPAREN          reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    COMMA           reduce using rule 50 (binary_op -> expression ISEQUALS expression .)
    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! AND             [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! OR              [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! GT              [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! LT              [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! GE              [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! LE              [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! ISEQUALS        [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! MODULO          [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! PLUS            [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! MINUS           [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! TIMES           [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 50 (binary_op -> expression ISEQUALS expression .) ]


state 84

    (47) binary_op -> expression LT expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 47 (binary_op -> expression LT expression .)
    OR              reduce using rule 47 (binary_op -> expression LT expression .)
    GT              reduce using rule 47 (binary_op -> expression LT expression .)
    LT              reduce using rule 47 (binary_op -> expression LT expression .)
    GE              reduce using rule 47 (binary_op -> expression LT expression .)
    LE              reduce using rule 47 (binary_op -> expression LT expression .)
    ISEQUALS        reduce using rule 47 (binary_op -> expression LT expression .)
    CONST           reduce using rule 47 (binary_op -> expression LT expression .)
    ID              reduce using rule 47 (binary_op -> expression LT expression .)
    CALL            reduce using rule 47 (binary_op -> expression LT expression .)
    RETURN          reduce using rule 47 (binary_op -> expression LT expression .)
    FUNCTION        reduce using rule 47 (binary_op -> expression LT expression .)
    IF              reduce using rule 47 (binary_op -> expression LT expression .)
    WHILE           reduce using rule 47 (binary_op -> expression LT expression .)
    FOR             reduce using rule 47 (binary_op -> expression LT expression .)
    INT             reduce using rule 47 (binary_op -> expression LT expression .)
    STRING          reduce using rule 47 (binary_op -> expression LT expression .)
    REAL            reduce using rule 47 (binary_op -> expression LT expression .)
    BOOLEAN         reduce using rule 47 (binary_op -> expression LT expression .)
    CHAR            reduce using rule 47 (binary_op -> expression LT expression .)
    $end            reduce using rule 47 (binary_op -> expression LT expression .)
    RBRACKET        reduce using rule 47 (binary_op -> expression LT expression .)
    LBRACKET        reduce using rule 47 (binary_op -> expression LT expression .)
    RPAREN          reduce using rule 47 (binary_op -> expression LT expression .)
    COMMA           reduce using rule 47 (binary_op -> expression LT expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! MODULO          [ reduce using rule 47 (binary_op -> expression LT expression .) ]
  ! PLUS            [ reduce using rule 47 (binary_op -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 47 (binary_op -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 47 (binary_op -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 47 (binary_op -> expression LT expression .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]


state 85

    (53) binary_op -> expression MINUS expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 53 (binary_op -> expression MINUS expression .)
    OR              reduce using rule 53 (binary_op -> expression MINUS expression .)
    GT              reduce using rule 53 (binary_op -> expression MINUS expression .)
    LT              reduce using rule 53 (binary_op -> expression MINUS expression .)
    GE              reduce using rule 53 (binary_op -> expression MINUS expression .)
    LE              reduce using rule 53 (binary_op -> expression MINUS expression .)
    ISEQUALS        reduce using rule 53 (binary_op -> expression MINUS expression .)
    PLUS            reduce using rule 53 (binary_op -> expression MINUS expression .)
    MINUS           reduce using rule 53 (binary_op -> expression MINUS expression .)
    CONST           reduce using rule 53 (binary_op -> expression MINUS expression .)
    ID              reduce using rule 53 (binary_op -> expression MINUS expression .)
    CALL            reduce using rule 53 (binary_op -> expression MINUS expression .)
    RETURN          reduce using rule 53 (binary_op -> expression MINUS expression .)
    FUNCTION        reduce using rule 53 (binary_op -> expression MINUS expression .)
    IF              reduce using rule 53 (binary_op -> expression MINUS expression .)
    WHILE           reduce using rule 53 (binary_op -> expression MINUS expression .)
    FOR             reduce using rule 53 (binary_op -> expression MINUS expression .)
    INT             reduce using rule 53 (binary_op -> expression MINUS expression .)
    STRING          reduce using rule 53 (binary_op -> expression MINUS expression .)
    REAL            reduce using rule 53 (binary_op -> expression MINUS expression .)
    BOOLEAN         reduce using rule 53 (binary_op -> expression MINUS expression .)
    CHAR            reduce using rule 53 (binary_op -> expression MINUS expression .)
    $end            reduce using rule 53 (binary_op -> expression MINUS expression .)
    RBRACKET        reduce using rule 53 (binary_op -> expression MINUS expression .)
    LBRACKET        reduce using rule 53 (binary_op -> expression MINUS expression .)
    RPAREN          reduce using rule 53 (binary_op -> expression MINUS expression .)
    COMMA           reduce using rule 53 (binary_op -> expression MINUS expression .)
    MODULO          shift and go to state 61
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! MODULO          [ reduce using rule 53 (binary_op -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 53 (binary_op -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 53 (binary_op -> expression MINUS expression .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 68 ]
  ! MINUS           [ shift and go to state 65 ]


state 86

    (48) binary_op -> expression GE expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 48 (binary_op -> expression GE expression .)
    OR              reduce using rule 48 (binary_op -> expression GE expression .)
    GT              reduce using rule 48 (binary_op -> expression GE expression .)
    LT              reduce using rule 48 (binary_op -> expression GE expression .)
    GE              reduce using rule 48 (binary_op -> expression GE expression .)
    LE              reduce using rule 48 (binary_op -> expression GE expression .)
    ISEQUALS        reduce using rule 48 (binary_op -> expression GE expression .)
    CONST           reduce using rule 48 (binary_op -> expression GE expression .)
    ID              reduce using rule 48 (binary_op -> expression GE expression .)
    CALL            reduce using rule 48 (binary_op -> expression GE expression .)
    RETURN          reduce using rule 48 (binary_op -> expression GE expression .)
    FUNCTION        reduce using rule 48 (binary_op -> expression GE expression .)
    IF              reduce using rule 48 (binary_op -> expression GE expression .)
    WHILE           reduce using rule 48 (binary_op -> expression GE expression .)
    FOR             reduce using rule 48 (binary_op -> expression GE expression .)
    INT             reduce using rule 48 (binary_op -> expression GE expression .)
    STRING          reduce using rule 48 (binary_op -> expression GE expression .)
    REAL            reduce using rule 48 (binary_op -> expression GE expression .)
    BOOLEAN         reduce using rule 48 (binary_op -> expression GE expression .)
    CHAR            reduce using rule 48 (binary_op -> expression GE expression .)
    $end            reduce using rule 48 (binary_op -> expression GE expression .)
    RBRACKET        reduce using rule 48 (binary_op -> expression GE expression .)
    LBRACKET        reduce using rule 48 (binary_op -> expression GE expression .)
    RPAREN          reduce using rule 48 (binary_op -> expression GE expression .)
    COMMA           reduce using rule 48 (binary_op -> expression GE expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! MODULO          [ reduce using rule 48 (binary_op -> expression GE expression .) ]
  ! PLUS            [ reduce using rule 48 (binary_op -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 48 (binary_op -> expression GE expression .) ]
  ! TIMES           [ reduce using rule 48 (binary_op -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 48 (binary_op -> expression GE expression .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]


state 87

    (49) binary_op -> expression LE expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 49 (binary_op -> expression LE expression .)
    OR              reduce using rule 49 (binary_op -> expression LE expression .)
    GT              reduce using rule 49 (binary_op -> expression LE expression .)
    LT              reduce using rule 49 (binary_op -> expression LE expression .)
    GE              reduce using rule 49 (binary_op -> expression LE expression .)
    LE              reduce using rule 49 (binary_op -> expression LE expression .)
    ISEQUALS        reduce using rule 49 (binary_op -> expression LE expression .)
    CONST           reduce using rule 49 (binary_op -> expression LE expression .)
    ID              reduce using rule 49 (binary_op -> expression LE expression .)
    CALL            reduce using rule 49 (binary_op -> expression LE expression .)
    RETURN          reduce using rule 49 (binary_op -> expression LE expression .)
    FUNCTION        reduce using rule 49 (binary_op -> expression LE expression .)
    IF              reduce using rule 49 (binary_op -> expression LE expression .)
    WHILE           reduce using rule 49 (binary_op -> expression LE expression .)
    FOR             reduce using rule 49 (binary_op -> expression LE expression .)
    INT             reduce using rule 49 (binary_op -> expression LE expression .)
    STRING          reduce using rule 49 (binary_op -> expression LE expression .)
    REAL            reduce using rule 49 (binary_op -> expression LE expression .)
    BOOLEAN         reduce using rule 49 (binary_op -> expression LE expression .)
    CHAR            reduce using rule 49 (binary_op -> expression LE expression .)
    $end            reduce using rule 49 (binary_op -> expression LE expression .)
    RBRACKET        reduce using rule 49 (binary_op -> expression LE expression .)
    LBRACKET        reduce using rule 49 (binary_op -> expression LE expression .)
    RPAREN          reduce using rule 49 (binary_op -> expression LE expression .)
    COMMA           reduce using rule 49 (binary_op -> expression LE expression .)
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! MODULO          [ reduce using rule 49 (binary_op -> expression LE expression .) ]
  ! PLUS            [ reduce using rule 49 (binary_op -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 49 (binary_op -> expression LE expression .) ]
  ! TIMES           [ reduce using rule 49 (binary_op -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 49 (binary_op -> expression LE expression .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]


state 88

    (52) binary_op -> expression PLUS expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 52 (binary_op -> expression PLUS expression .)
    OR              reduce using rule 52 (binary_op -> expression PLUS expression .)
    GT              reduce using rule 52 (binary_op -> expression PLUS expression .)
    LT              reduce using rule 52 (binary_op -> expression PLUS expression .)
    GE              reduce using rule 52 (binary_op -> expression PLUS expression .)
    LE              reduce using rule 52 (binary_op -> expression PLUS expression .)
    ISEQUALS        reduce using rule 52 (binary_op -> expression PLUS expression .)
    PLUS            reduce using rule 52 (binary_op -> expression PLUS expression .)
    MINUS           reduce using rule 52 (binary_op -> expression PLUS expression .)
    CONST           reduce using rule 52 (binary_op -> expression PLUS expression .)
    ID              reduce using rule 52 (binary_op -> expression PLUS expression .)
    CALL            reduce using rule 52 (binary_op -> expression PLUS expression .)
    RETURN          reduce using rule 52 (binary_op -> expression PLUS expression .)
    FUNCTION        reduce using rule 52 (binary_op -> expression PLUS expression .)
    IF              reduce using rule 52 (binary_op -> expression PLUS expression .)
    WHILE           reduce using rule 52 (binary_op -> expression PLUS expression .)
    FOR             reduce using rule 52 (binary_op -> expression PLUS expression .)
    INT             reduce using rule 52 (binary_op -> expression PLUS expression .)
    STRING          reduce using rule 52 (binary_op -> expression PLUS expression .)
    REAL            reduce using rule 52 (binary_op -> expression PLUS expression .)
    BOOLEAN         reduce using rule 52 (binary_op -> expression PLUS expression .)
    CHAR            reduce using rule 52 (binary_op -> expression PLUS expression .)
    $end            reduce using rule 52 (binary_op -> expression PLUS expression .)
    RBRACKET        reduce using rule 52 (binary_op -> expression PLUS expression .)
    LBRACKET        reduce using rule 52 (binary_op -> expression PLUS expression .)
    RPAREN          reduce using rule 52 (binary_op -> expression PLUS expression .)
    COMMA           reduce using rule 52 (binary_op -> expression PLUS expression .)
    MODULO          shift and go to state 61
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! MODULO          [ reduce using rule 52 (binary_op -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 52 (binary_op -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 52 (binary_op -> expression PLUS expression .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 68 ]
  ! MINUS           [ shift and go to state 65 ]


state 89

    (54) binary_op -> expression TIMES expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    AND             reduce using rule 54 (binary_op -> expression TIMES expression .)
    OR              reduce using rule 54 (binary_op -> expression TIMES expression .)
    GT              reduce using rule 54 (binary_op -> expression TIMES expression .)
    LT              reduce using rule 54 (binary_op -> expression TIMES expression .)
    GE              reduce using rule 54 (binary_op -> expression TIMES expression .)
    LE              reduce using rule 54 (binary_op -> expression TIMES expression .)
    ISEQUALS        reduce using rule 54 (binary_op -> expression TIMES expression .)
    MODULO          reduce using rule 54 (binary_op -> expression TIMES expression .)
    PLUS            reduce using rule 54 (binary_op -> expression TIMES expression .)
    MINUS           reduce using rule 54 (binary_op -> expression TIMES expression .)
    TIMES           reduce using rule 54 (binary_op -> expression TIMES expression .)
    DIVIDE          reduce using rule 54 (binary_op -> expression TIMES expression .)
    CONST           reduce using rule 54 (binary_op -> expression TIMES expression .)
    ID              reduce using rule 54 (binary_op -> expression TIMES expression .)
    CALL            reduce using rule 54 (binary_op -> expression TIMES expression .)
    RETURN          reduce using rule 54 (binary_op -> expression TIMES expression .)
    FUNCTION        reduce using rule 54 (binary_op -> expression TIMES expression .)
    IF              reduce using rule 54 (binary_op -> expression TIMES expression .)
    WHILE           reduce using rule 54 (binary_op -> expression TIMES expression .)
    FOR             reduce using rule 54 (binary_op -> expression TIMES expression .)
    INT             reduce using rule 54 (binary_op -> expression TIMES expression .)
    STRING          reduce using rule 54 (binary_op -> expression TIMES expression .)
    REAL            reduce using rule 54 (binary_op -> expression TIMES expression .)
    BOOLEAN         reduce using rule 54 (binary_op -> expression TIMES expression .)
    CHAR            reduce using rule 54 (binary_op -> expression TIMES expression .)
    $end            reduce using rule 54 (binary_op -> expression TIMES expression .)
    RBRACKET        reduce using rule 54 (binary_op -> expression TIMES expression .)
    LBRACKET        reduce using rule 54 (binary_op -> expression TIMES expression .)
    RPAREN          reduce using rule 54 (binary_op -> expression TIMES expression .)
    COMMA           reduce using rule 54 (binary_op -> expression TIMES expression .)

  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 70 ]
  ! GT              [ shift and go to state 60 ]
  ! LT              [ shift and go to state 64 ]
  ! GE              [ shift and go to state 66 ]
  ! LE              [ shift and go to state 67 ]
  ! ISEQUALS        [ shift and go to state 63 ]
  ! MODULO          [ shift and go to state 61 ]
  ! PLUS            [ shift and go to state 68 ]
  ! MINUS           [ shift and go to state 65 ]
  ! TIMES           [ shift and go to state 69 ]
  ! DIVIDE          [ shift and go to state 62 ]


state 90

    (45) binary_op -> expression OR expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    OR              reduce using rule 45 (binary_op -> expression OR expression .)
    ISEQUALS        reduce using rule 45 (binary_op -> expression OR expression .)
    CONST           reduce using rule 45 (binary_op -> expression OR expression .)
    ID              reduce using rule 45 (binary_op -> expression OR expression .)
    CALL            reduce using rule 45 (binary_op -> expression OR expression .)
    RETURN          reduce using rule 45 (binary_op -> expression OR expression .)
    FUNCTION        reduce using rule 45 (binary_op -> expression OR expression .)
    IF              reduce using rule 45 (binary_op -> expression OR expression .)
    WHILE           reduce using rule 45 (binary_op -> expression OR expression .)
    FOR             reduce using rule 45 (binary_op -> expression OR expression .)
    INT             reduce using rule 45 (binary_op -> expression OR expression .)
    STRING          reduce using rule 45 (binary_op -> expression OR expression .)
    REAL            reduce using rule 45 (binary_op -> expression OR expression .)
    BOOLEAN         reduce using rule 45 (binary_op -> expression OR expression .)
    CHAR            reduce using rule 45 (binary_op -> expression OR expression .)
    $end            reduce using rule 45 (binary_op -> expression OR expression .)
    RBRACKET        reduce using rule 45 (binary_op -> expression OR expression .)
    LBRACKET        reduce using rule 45 (binary_op -> expression OR expression .)
    RPAREN          reduce using rule 45 (binary_op -> expression OR expression .)
    COMMA           reduce using rule 45 (binary_op -> expression OR expression .)
    AND             shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62

  ! AND             [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! GT              [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! LT              [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! GE              [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! LE              [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! MODULO          [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! PLUS            [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 45 (binary_op -> expression OR expression .) ]
  ! OR              [ shift and go to state 70 ]
  ! ISEQUALS        [ shift and go to state 63 ]


state 91

    (21) if_statement -> IF binary_op LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    RBRACKET        shift and go to state 103
    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    identifier                     shift and go to state 25
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 47
    if_statement                   shift and go to state 11
    func_declaration               shift and go to state 19

state 92

    (19) func_declaration -> FUNCTION identifier LPAREN RPAREN . COLON RETURNS type_info LBRACKET translation_unit RBRACKET

    COLON           shift and go to state 104


state 93

    (26) params_list -> parameter_declaration .

    RPAREN          reduce using rule 26 (params_list -> parameter_declaration .)
    COMMA           reduce using rule 26 (params_list -> parameter_declaration .)


state 94

    (28) parameter_declaration -> type_info . identifier
    (38) identifier -> . ID

    ID              shift and go to state 28

    identifier                     shift and go to state 105

state 95

    (18) func_declaration -> FUNCTION identifier LPAREN params_list . RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (27) params_list -> params_list . COMMA parameter_declaration

    RPAREN          shift and go to state 106
    COMMA           shift and go to state 107


state 96

    (25) for_statement -> FOR ID IN func_call .

    RBRACKET        reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    CONST           reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    ID              reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    CALL            reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    RETURN          reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    FUNCTION        reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    IF              reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    WHILE           reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    FOR             reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    INT             reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    STRING          reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    REAL            reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    BOOLEAN         reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    CHAR            reduce using rule 25 (for_statement -> FOR ID IN func_call .)
    $end            reduce using rule 25 (for_statement -> FOR ID IN func_call .)


state 97

    (24) for_statement -> FOR ID IN ID .

    RBRACKET        reduce using rule 24 (for_statement -> FOR ID IN ID .)
    CONST           reduce using rule 24 (for_statement -> FOR ID IN ID .)
    ID              reduce using rule 24 (for_statement -> FOR ID IN ID .)
    CALL            reduce using rule 24 (for_statement -> FOR ID IN ID .)
    RETURN          reduce using rule 24 (for_statement -> FOR ID IN ID .)
    FUNCTION        reduce using rule 24 (for_statement -> FOR ID IN ID .)
    IF              reduce using rule 24 (for_statement -> FOR ID IN ID .)
    WHILE           reduce using rule 24 (for_statement -> FOR ID IN ID .)
    FOR             reduce using rule 24 (for_statement -> FOR ID IN ID .)
    INT             reduce using rule 24 (for_statement -> FOR ID IN ID .)
    STRING          reduce using rule 24 (for_statement -> FOR ID IN ID .)
    REAL            reduce using rule 24 (for_statement -> FOR ID IN ID .)
    BOOLEAN         reduce using rule 24 (for_statement -> FOR ID IN ID .)
    CHAR            reduce using rule 24 (for_statement -> FOR ID IN ID .)
    $end            reduce using rule 24 (for_statement -> FOR ID IN ID .)


state 98

    (16) func_call -> CALL identifier LPAREN arguments_list . RPAREN
    (30) arguments_list -> arguments_list . COMMA expression

    RPAREN          shift and go to state 108
    COMMA           shift and go to state 109


state 99

    (17) func_call -> CALL identifier LPAREN RPAREN .

    AND             reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    OR              reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    GT              reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    LT              reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    GE              reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    LE              reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    ISEQUALS        reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    MODULO          reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    PLUS            reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    MINUS           reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    TIMES           reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    DIVIDE          reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    CONST           reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    ID              reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    CALL            reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    RETURN          reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    FUNCTION        reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    IF              reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    WHILE           reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    FOR             reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    INT             reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    STRING          reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    REAL            reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    BOOLEAN         reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    CHAR            reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    $end            reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    RBRACKET        reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    LBRACKET        reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    RPAREN          reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)
    COMMA           reduce using rule 17 (func_call -> CALL identifier LPAREN RPAREN .)


state 100

    (29) arguments_list -> expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    RPAREN          reduce using rule 29 (arguments_list -> expression .)
    COMMA           reduce using rule 29 (arguments_list -> expression .)
    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62


state 101

    (13) assignment -> CONST type_info identifier EQUALS value .

    RBRACKET        reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    CONST           reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    ID              reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    CALL            reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    RETURN          reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    FUNCTION        reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    IF              reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    WHILE           reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    FOR             reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    INT             reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    STRING          reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    REAL            reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    BOOLEAN         reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    CHAR            reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)
    $end            reduce using rule 13 (assignment -> CONST type_info identifier EQUALS value .)


state 102

    (23) while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .

    RBRACKET        reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    CONST           reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    FOR             reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 23 (while_statement -> WHILE binary_op LBRACKET translation_unit RBRACKET .)


state 103

    (21) if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .

    RBRACKET        reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    CONST           reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    FOR             reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 21 (if_statement -> IF binary_op LBRACKET translation_unit RBRACKET .)


state 104

    (19) func_declaration -> FUNCTION identifier LPAREN RPAREN COLON . RETURNS type_info LBRACKET translation_unit RBRACKET

    RETURNS         shift and go to state 110


state 105

    (28) parameter_declaration -> type_info identifier .

    RPAREN          reduce using rule 28 (parameter_declaration -> type_info identifier .)
    COMMA           reduce using rule 28 (parameter_declaration -> type_info identifier .)


state 106

    (18) func_declaration -> FUNCTION identifier LPAREN params_list RPAREN . COLON RETURNS type_info LBRACKET translation_unit RBRACKET

    COLON           shift and go to state 111


state 107

    (27) params_list -> params_list COMMA . parameter_declaration
    (28) parameter_declaration -> . type_info identifier
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    parameter_declaration          shift and go to state 112
    type_info                      shift and go to state 94

state 108

    (16) func_call -> CALL identifier LPAREN arguments_list RPAREN .

    AND             reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    OR              reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    GT              reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    LT              reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    GE              reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    LE              reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    ISEQUALS        reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    MODULO          reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    PLUS            reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    MINUS           reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    TIMES           reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    DIVIDE          reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    CONST           reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    ID              reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    CALL            reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    RETURN          reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    FUNCTION        reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    IF              reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    WHILE           reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    FOR             reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    INT             reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    STRING          reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    REAL            reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    BOOLEAN         reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    CHAR            reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    $end            reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    RBRACKET        reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    LBRACKET        reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    RPAREN          reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)
    COMMA           reduce using rule 16 (func_call -> CALL identifier LPAREN arguments_list RPAREN .)


state 109

    (30) arguments_list -> arguments_list COMMA . expression
    (31) expression -> . simple_expression
    (32) expression -> . func_call
    (33) expression -> . atom
    (34) simple_expression -> . binary_op
    (35) simple_expression -> . unary_op
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (36) atom -> . identifier
    (37) atom -> . value
    (44) binary_op -> . expression AND expression
    (45) binary_op -> . expression OR expression
    (46) binary_op -> . expression GT expression
    (47) binary_op -> . expression LT expression
    (48) binary_op -> . expression GE expression
    (49) binary_op -> . expression LE expression
    (50) binary_op -> . expression ISEQUALS expression
    (51) binary_op -> . expression MODULO expression
    (52) binary_op -> . expression PLUS expression
    (53) binary_op -> . expression MINUS expression
    (54) binary_op -> . expression TIMES expression
    (55) binary_op -> . expression DIVIDE expression
    (56) unary_op -> . MINUS expression
    (57) unary_op -> . NOT expression
    (38) identifier -> . ID
    (39) value -> . NUMBER
    (40) value -> . SLITERAL
    (41) value -> . FLOAT
    (42) value -> . TRUE
    (43) value -> . FALSE

    CALL            shift and go to state 24
    MINUS           shift and go to state 33
    NOT             shift and go to state 41
    ID              shift and go to state 28
    NUMBER          shift and go to state 29
    SLITERAL        shift and go to state 34
    FLOAT           shift and go to state 39
    TRUE            shift and go to state 32
    FALSE           shift and go to state 38

    func_call                      shift and go to state 35
    binary_op                      shift and go to state 45
    value                          shift and go to state 40
    unary_op                       shift and go to state 30
    atom                           shift and go to state 37
    simple_expression              shift and go to state 31
    identifier                     shift and go to state 42
    expression                     shift and go to state 113

state 110

    (19) func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS . type_info LBRACKET translation_unit RBRACKET
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    type_info                      shift and go to state 114

state 111

    (18) func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON . RETURNS type_info LBRACKET translation_unit RBRACKET

    RETURNS         shift and go to state 115


state 112

    (27) params_list -> params_list COMMA parameter_declaration .

    RPAREN          reduce using rule 27 (params_list -> params_list COMMA parameter_declaration .)
    COMMA           reduce using rule 27 (params_list -> params_list COMMA parameter_declaration .)


state 113

    (30) arguments_list -> arguments_list COMMA expression .
    (44) binary_op -> expression . AND expression
    (45) binary_op -> expression . OR expression
    (46) binary_op -> expression . GT expression
    (47) binary_op -> expression . LT expression
    (48) binary_op -> expression . GE expression
    (49) binary_op -> expression . LE expression
    (50) binary_op -> expression . ISEQUALS expression
    (51) binary_op -> expression . MODULO expression
    (52) binary_op -> expression . PLUS expression
    (53) binary_op -> expression . MINUS expression
    (54) binary_op -> expression . TIMES expression
    (55) binary_op -> expression . DIVIDE expression

    RPAREN          reduce using rule 30 (arguments_list -> arguments_list COMMA expression .)
    COMMA           reduce using rule 30 (arguments_list -> arguments_list COMMA expression .)
    AND             shift and go to state 59
    OR              shift and go to state 70
    GT              shift and go to state 60
    LT              shift and go to state 64
    GE              shift and go to state 66
    LE              shift and go to state 67
    ISEQUALS        shift and go to state 63
    MODULO          shift and go to state 61
    PLUS            shift and go to state 68
    MINUS           shift and go to state 65
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 62


state 114

    (19) func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info . LBRACKET translation_unit RBRACKET

    LBRACKET        shift and go to state 116


state 115

    (18) func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS . type_info LBRACKET translation_unit RBRACKET
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    type_info                      shift and go to state 117

state 116

    (19) func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    if_statement                   shift and go to state 11
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 10
    identifier                     shift and go to state 25
    translation_unit               shift and go to state 118
    func_declaration               shift and go to state 19

state 117

    (18) func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info . LBRACKET translation_unit RBRACKET

    LBRACKET        shift and go to state 119


state 118

    (19) func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    RBRACKET        shift and go to state 120
    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    if_statement                   shift and go to state 11
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 47
    identifier                     shift and go to state 25
    func_declaration               shift and go to state 19

state 119

    (18) func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET . translation_unit RBRACKET
    (2) translation_unit -> . statement
    (3) translation_unit -> . translation_unit statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    if_statement                   shift and go to state 11
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 10
    identifier                     shift and go to state 25
    translation_unit               shift and go to state 121
    func_declaration               shift and go to state 19

state 120

    (19) func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .

    CONST           reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    FOR             reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    RBRACKET        reduce using rule 19 (func_declaration -> FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)


state 121

    (18) func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit . RBRACKET
    (3) translation_unit -> translation_unit . statement
    (4) statement -> . assignment
    (5) statement -> . func_call
    (6) statement -> . return_statement
    (7) statement -> . func_declaration
    (8) statement -> . if_statement
    (9) statement -> . while_statement
    (10) statement -> . for_statement
    (11) assignment -> . identifier EQUALS expression
    (12) assignment -> . type_info identifier EQUALS expression
    (13) assignment -> . CONST type_info identifier EQUALS value
    (14) assignment -> . ID PLUSPLUS
    (15) assignment -> . ID MINUSMINUS
    (16) func_call -> . CALL identifier LPAREN arguments_list RPAREN
    (17) func_call -> . CALL identifier LPAREN RPAREN
    (20) return_statement -> . RETURN expression
    (18) func_declaration -> . FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (19) func_declaration -> . FUNCTION identifier LPAREN RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET
    (21) if_statement -> . IF binary_op LBRACKET translation_unit RBRACKET
    (23) while_statement -> . WHILE binary_op LBRACKET translation_unit RBRACKET
    (24) for_statement -> . FOR ID IN ID
    (25) for_statement -> . FOR ID IN func_call
    (38) identifier -> . ID
    (58) type_info -> . INT
    (59) type_info -> . STRING
    (60) type_info -> . REAL
    (61) type_info -> . BOOLEAN
    (62) type_info -> . CHAR

    RBRACKET        shift and go to state 122
    CONST           shift and go to state 2
    ID              shift and go to state 18
    CALL            shift and go to state 24
    RETURN          shift and go to state 6
    FUNCTION        shift and go to state 13
    IF              shift and go to state 5
    WHILE           shift and go to state 4
    FOR             shift and go to state 16
    INT             shift and go to state 22
    STRING          shift and go to state 15
    REAL            shift and go to state 1
    BOOLEAN         shift and go to state 23
    CHAR            shift and go to state 21

    func_call                      shift and go to state 20
    for_statement                  shift and go to state 14
    if_statement                   shift and go to state 11
    assignment                     shift and go to state 17
    type_info                      shift and go to state 3
    return_statement               shift and go to state 7
    while_statement                shift and go to state 8
    statement                      shift and go to state 47
    identifier                     shift and go to state 25
    func_declaration               shift and go to state 19

state 122

    (18) func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .

    CONST           reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    ID              reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    CALL            reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    RETURN          reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    FUNCTION        reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    IF              reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    WHILE           reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    FOR             reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    INT             reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    STRING          reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    REAL            reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    BOOLEAN         reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    CHAR            reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    $end            reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)
    RBRACKET        reduce using rule 18 (func_declaration -> FUNCTION identifier LPAREN params_list RPAREN COLON RETURNS type_info LBRACKET translation_unit RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 58 resolved as shift
WARNING: shift/reduce conflict for OR in state 58 resolved as shift
WARNING: shift/reduce conflict for GT in state 58 resolved as shift
WARNING: shift/reduce conflict for LT in state 58 resolved as shift
WARNING: shift/reduce conflict for GE in state 58 resolved as shift
WARNING: shift/reduce conflict for LE in state 58 resolved as shift
WARNING: shift/reduce conflict for ISEQUALS in state 58 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 58 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 58 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 58 resolved as shift
WARNING: shift/reduce conflict for AND in state 83 resolved as shift
WARNING: shift/reduce conflict for OR in state 83 resolved as shift
WARNING: shift/reduce conflict for GT in state 83 resolved as shift
WARNING: shift/reduce conflict for LT in state 83 resolved as shift
WARNING: shift/reduce conflict for GE in state 83 resolved as shift
WARNING: shift/reduce conflict for LE in state 83 resolved as shift
WARNING: shift/reduce conflict for ISEQUALS in state 83 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
